#Module2 #PearsonNotes 
# 9.10 - Using Smart Pointers to Avoid Memory Leaks
Beginning with C++ 11, you can use **smart pointers** to dynamically allocate memory and not worry about deleting the memory when you are finished using it.
A smart pointer automatically delete a chunk of dynamically allocated memory when the memory is no longer being used. This helps to prevent memory leaks from occurring.
Modern C++ provides 3 types of smart pointer:
- `unique_ptr` - It's the sole owner of a piece of dynamically allocate memory. No 2 `unique_ptrs` can point to the same piece of memory. When a `unique_ptr` goes out of scope, it automatically deallocates the piece of memory that it points to.
- `sharted_ptr` - A `shared_ptr` can share ownership of a piece of dynamically allocate memory. Multiple pointers of the `shared_ptr` type can point to the same  piece of memory. the memory is deallocated when the last `shared_ptr` that is pointing to is destroyed.
- `weak_prt` - A `weak_ptr` doesn't own the memory it points to, and cannot be used to access the memory's contents. It is used in special situations where the memory point to by a `shared_ptr` must be reference without increasing the number of `shared_ptrs` that own it.

To use any smart pointers:
```c++
#include <memory>
```

```c++
unique_ptr<int> ptr(new int);
```
This statements defines a `unique_ptr` named `ptr` that points to a dynamically allocated int.
- The notation `<int>` that appears immediately after `unique_ptr` indicates that the pointer can point to an int.
- The expression `new int` that appears inside the parenthesis allocates a chunk of memory to hold an `int`. The address of the chunk of memory will be assigned to the `ptr` pointer.

## Figure 9-12
Definition of a `unique_ptr`
![9.10 - Figure 9-12](/Module%202/Pearson%20Notes/9.10%20Photos/Figure%209-12.png)

## Program 9-17: `unique_ptr` Example
```c++
  // This program demonstrates a unique_ptr.
  #include <iostream>
  #include <memory>
  using namespace std;

  int main()
  {
      // Define a unique_ptr smart pointer, pointing
      // to a dynamically allocated int.
      unique_ptr<int> ptr( new int );

      // Assign 99 to the dynamically allocated int.
      *ptr = 99;

      // Display the value of the dynamically allocated int.
      cout << *ptr << endl;
      return 0;
  }

	// =============== Output ===============
	// 99
```
This program demonstrates a `unique_ptr`, but it isn't very practical. Dynamically allocating an array is more useful than allocating a single integer.

```c++
const int SIZE = 100;
unique_ptr<int[]> ptr(new int[SIZE]);
```
- Following `unique_ptr`, the notation `<int[]>` indicates that the pointer will point to an array of `int`s.
- The expression inside the parentheses, `new int[SIZE]` allocates an array of `int`s.

The address of the dynamically allocated array of `ints` will be assigned to the `ptr` pointer. After the definition statement, you can sue the `[]` operator with subscripts to access the array of elements.
```c++
ptr[0] = 99;
cout << ptr[0] << endl;
```
The first statement assigns the value 99 to `ptr[0]` and the second statement displays the value of `ptr[0]`

## Program 9-18
```c++
 // This program demonstrates a unique_ptr pointing
 // to a dynamically allocated array of integers.
 #include <iostream>
 #include <memory>
 using namespace std;
 
 int main()
 {
     int max; // Max size of the array
     
      // Get the number of values to store.
      cout << "How many numbers do you want to enter? ";
      cin >> max;

      // Define a unique_ptr smart pointer, pointing
      // to a dynamically allocated array of ints.
      unique_ptr<int[]> ptr( new int[max]);

      // Get values for the array.
      for (int index = 0; index < max; index++)
      {
           cout << "Enter an integer number: ";
           cin >> ptr[index];
      }

      // Display the values in the array.
      cout << "Here are the values you entered:\n";
      for (int index = 0; index < max; index++)
           cout << ptr[index] << endl;
      return 0;
 }

	// =============== Output ===============
	// How many numbers do you want to enter? 5 [Enter]
	// Enter an integer number: 1 [Enter]
	// Enter an integer number: 2 [Enter]
	// Enter an integer number: 3 [Enter]
	// Enter an integer number: 4 [Enter]
	// Enter an integer number: 5 [Enter]
	// Here are the values you entered:
	// 1
	// 2
	// 3
	// 4
	// 5
```

You can define an uninitialized `unique_ptr`, then assign it a value in a later statement.
```c++
unique_ptr<int> ptr;
ptr = unique_ptr<int>(new int);
```

Smart pointers support the same `*` and `->` dereferencing operators as regular pointers, but smart pointers do not support pointer aithmetic.
```c++
unique_ptr<int[]> ptr(new int[MAX]);
ptr++; // ERROR
```