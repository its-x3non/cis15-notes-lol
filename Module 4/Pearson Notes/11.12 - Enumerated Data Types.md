[Table of Contents](/README.md) | [Previous Section](11.11%20-%20Focus%20on%20Software%20Engineering.md) | [Next Section (Go to Next Chapter)](../../Module%205/Pearson%20Notes/12.1%20-%20File%20Operations.md) | [All Sections](/Module%204/Pearson%20Notes/)<br />
***
#Module4 #PearsonNotes <br />
### Since this is a long section here are a table of contents for each section (In Order):
#### Table of Contents
- 11.12 - Enumerated Data Types
- [Assigning an Integer to an `enum` Variable](#Assigning-an-Integer-to-an-enum-Variable)
- [Assigning an Enumerator to an `int` Variable](#Assigning-an-Enumerator-to-an-int-Variable)
- [Comparing Enumerator Values](#Comparing-Enumerator-Values)
- [Anonymous Enumerated Types](#Anonymous-Enumerated-Types)
- [Using Math Operators to change the Value of an `enum` Variable](#Using-Math-Operators-to-change-the-Value-of-an-enum-Variable)
- [Using an `enum` Variable to Step through an Array's Elements](#Using-an-enum-Variable-to-Step-through-an-Array's-Elements)
- [Using Enumerators to Output Values](#Using-Enumerators-to-Output-Values)
- [Specifying Integer Values for Enumerators](#Specifying-Integer-Values-For-Enumerators)
- [Enumerators Must Be Unique within the Same Scope](#Enumerators-Must-Be-Unique-within-the-Same-Scope)
- [Declaring the Type and Defining the Variables in One Statement](#Declaring-the-Type-and-Defining-the-Variables-in-One-Statement)
- [Strong Type `enums`](#Strong-Type-enums)
***
# 11.12 - Enumerated Data Types
Using the `enum` key word, you can create your own data type and specify the values that belong to that type. Such a type is known as an **enumerated data type**.
For example:
```c++
enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY };
```

An enumerated type declaration begins with the key word `enum`, followed by the name of the type, followed by a list of identifiers inside braces, and is terminated with a semicolon. The example declaration creates an enumerated data type named `Day`. The identifiers `MONDAY, TUESDAY, WEDNESDAY, THURSDAY, and FRIDAY`, which are listed inside the braces, are known as **enumerators**. They represent the values that belong to the Day data type. Here is the general format of an enumerated type declaration:
```c++
enum TypeName { One or more enumerators };
```

Note the enumerators are not enclosed in quotation marks; therefore, they are not strings. Enumerators must be legal C++ identifiers.

Once you have created an enumerated data type in your program, you can define variables of that type. For example, the following statement defines `workDay` as a variable of the `Day` type:
```c++
Day workDay;
```

Because `workDay` is a variable of the `Day` data type, we may assign any of the enumerators `MONDAY, TUESDAY, WEDNESDAY, THURSDAY, or FRIDAY` to it. For example, the following statement assigns the value `WEDNESDAY` to the `workDay` variable.
```c++
Day workDay = WEDNESDAY;
```

So just what are these enumerators `MONDAY, TUESDAY, WEDNESDAY, THURSDAY, and FRIDAY`? You can think of them as integer named constants. Internally, the compiler assigns integer values to the enumerators, beginning with 0. The enumerator `MONDAY` is stored in memory as the number 0, `TUESDAY` is stored in memory as the number 1, `WEDNESDAY` is stored in memory as the number 2, and so forth. To prove this, look at the following code.
```c++
cout  << MONDAY << endl << TUESDAY << endl 
		<< WEDNESDAY << endl << THURSDAY << endl
		<< FRIDAY << endl;

// = Output =
// 0
// 1
// 2
// 3
// 4
// ===========
```

**NOTE:** When making up names for enumerators, it is not required that they be written in all uppercase letters. For example, we could have written the enumerators of the Days type as `monday, tuesday`, and so on. Because they represent constant values, however, many programmers prefer to write them in all uppercase letters. This is strictly a preference of style.

#### [BACK TO THE TOP](#Table-of-Contents)

# Assigning an Integer to an enum Variable
Even though the enumerators of an enumerated data type are stored in memory as integers, you cannot directly assign an integer value to an `enum` variable. 
For example, assuming that `workDay` is a variable of the `Day` data type previously described, the following assignment statement is illegal:
```c++
workDay = 3; // Error
```

Compiling this statement will produce an error message such as “Cannot convert `int` to `Day`.” When assigning a value to an `enum` variable, you should use a valid enumerator. However, if circumstances require that you store an integer value in an `enum` variable, you can do so by casting the integer. Here is an example:
```c++
workDay = static_cast<Day>(3);
// SAME AS
workDay = THURSDAY;
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Assigning an Enumerator to an int Variable
Although you cannot directly assign an integer value to an `enum` variable, you can directly assign an enumerator to an integer variable. 
For example:
```c++
enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY };
int x;
x = THURSDAY;
cout << x << endl;

// = Output =
// 3
// ==========
```

You can also assign a variable of an enumerated type to an integer variable:
```c++
Day workDay = FRIDAY;
int x = workDay;
cout << x << endl;

// = Output =
// 4
// ==========
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Comparing Enumerator Values
Enumerator values can be compared using the relational operators. For example, using the `Day` data type we have been discussing, the following expression is `true`:
```c++
FRIDAY > MONDAY

// = (Technical) Output =
// True
// ======================
```

The expression is true because the enumerator `FRIDAY` is stored in memory as 4 and the enumerator `MONDAY` is stored as 0. The following code will display the message “Friday is greater than Monday.”:
```c++
if (FRIDAY > MONDAY)
	cout << "Friday is greater than Monday. \n";
```

You can also compare enumerator values with integer values. For example, the following code will display the message “Monday is equal to zero.”:
```c++
if (MONDAY == 0)
	cout << "Monday is equal to zero.\n";
```

## Program 11-10
Uses the `Day` Data Type that has been discussed
```c++
   // This program demonstrates an enumerated data type. 
   #include <iostream> 
   #include <iomanip> 
   using namespace std; 

   enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY }; 

   int main() 
   { 
      const int NUM_DAYS = 5;    // The number of days 
      double sales[NUM_DAYS];    // To hold sales for each day 
      double total = 0.0;        // Accumulator 
      int index;                 // Loop counter 

      // Get the sales for each day. 
      for (index = MONDAY; index <= FRIDAY; index++) 
      { 

          cout << "Enter the sales for day " 
               << index << ": "; 
          cin >> sales[index]; 
      } 

      // Calculate the total sales. 
      for (index = MONDAY; index <= FRIDAY; index++) 
         total += sales[index]; 

      // Display the total. 
      cout << "The total sales are $" << setprecision(2) 
           << fixed << total << endl; 
      return 0; 
  }

// =============== Output ===============
// Enter the sales for day 0: 1525.00 [Enter]
// Enter the sales for day 1: 1896.50 [Enter]
// Enter the sales for day 2: 1975.63 [Enter]
// Enter the sales for day 3: 1678.33 [Enter]
// Enter the sales for day 4: 1498.52 [Enter]
// The total sales are $8573.98
// ======================================
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Anonymous Enumerated Types
Notice [Program 11-10](#Program-11-10) does not define a variable of the `Day` data type. Instead, it uses the Day data type’s enumerators in the `for` loops. The counter variable `index` is initialized to `MONDAY` (which is 0), and the loop iterates as long as `index` is less than or equal to `FRIDAY` (which is 4). When you do not need to define variables of an enumerated type, you can actually make the type anonymous. An **anonymous enumerated type** is simply one that does not have a name. For example, in [Program 11-10](#Program-11-10) we could have declared the enumerated type as:
```c++
enum { MONDAY, TUESDAY, WEDNESDAY, THUSRDAY, FRIDAY};
```

This declaration still creates the enumerators. We just can’t use the data type to define variables, because the type does not have a name.

#### [BACK TO THE TOP](#Table-of-Contents)

# Using Math Operators to Change the Value of an enum Variable
Even though enumerators are really integers, and `enum` variables really hold integer values, you can run into problems when trying to perform math operations with them. For example, look at the following code:
```c++
Day day1, day2; // Defines 2 Day variables
day1 = TUESDAY; // Assign TUESDAY to day1
day2 = day1 + 1; // Will not work
```

The third statement causes a problem because the expression `day1 + 1﻿` results in the integer value 2. The assignment operator then attempts to assign the integer value 2 to the `enum` variable `day2`. Because C++ cannot implicitly convert an `int` to a `Day`, an error occurs. You can fix this by using a cast to explicitly convert the result to `Day`, as shown here:
```c++
day2 = static_cast<Day>(day1 + 1);
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Using an enum Variable to Step through an Array's Elements
Because enumerators are stored in memory as integers, you can use them as array subscripts. For example:
```c++
enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY }; 
const int NUM_DAYS = 5;  double sales[NUM_DAYS]; 
sales[MONDAY] = 1525.0;      // Stores 1525.0 in sales[0]. 
sales[TUESDAY] = 1896.5;     // Stores 1896.5 in sales[1]. 
sales[WEDNESDAY] = 1975.63;  // Stores 1975.63 in sales[2]. 
sales[THURSDAY] = 1678.33;   // Stores 1678.33 in sales[3]. 
sales[FRIDAY] = 1498.52;     // Stores 1498.52 in sales[4].
```

This code stores values in all five elements of the sales array. Because enumerator values can be used as array subscripts, you can use an `enum` variable in a loop to step through the elements of an array. However, using an `enum` variable for this purpose is not as straightforward as using an `int` variable. This is because you cannot use the `++` or `−−` operators directly on an `enum` variable. To understand this, first look at the following code taken from [Program 11-10](#Program-11-10):
```c++
for (index = MONDAY; index <= FRIDAY; index++)
{
	cout << "Enter the sales for day "
		<< index << ": ";
	cin >> sales[index];
}
```
`index` here is an `int` variable used to step through each element of the array. It is reasonable to expect that we could use a `Day` variable instead:
```c++
Day workDay;  // Define a Day variable 
// ERROR!!! This code will NOT work. 
for (workDay = MONDAY; workDay <= FRIDAY; workDay++)
{
	cout << "Enter the sales for day "
	<< workDay << ": ";
	cin >> sales[workDay]; 
}
```
This does not work because the `++` operator cannot be used with an `enum` variable. Instead, you must convert `workDay++` to an equivalent expression that will work:
```c++
workDay = workDay + 1; // doesn't work
workDay = static_cast<Day>(workDay + 1); // Works :D
```
The corrected `for loop` looks like this:
```c++
for (workDay = MONDAY; workDay <= FRIDAY;               workDay = static_cast<Day>(workDay + 1))
{
	cout << "Enter the sales for day "
	<< workDay << ": ";
	cin >> sales[workDay];
}
```

## Program 11-11
A modified version of [Program 11-10](#Program-11-10) that is made to use a `Day` variable to step through the elements of the `sales` array.
```c++
   // This program demonstrates an enumerated data type. 
   #include <iostream> 
   #include <iomanip> 
   using namespace std; 

   enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY }; 

   int main() 
   { 
      const int NUM_DAYS = 5;     // The number of days 
      double sales[NUM_DAYS];     // To hold sales for each day 
      double total = 0.0;         // Accumulator 
      Day workDay;                // Loop counter 

      // Get the sales for each day. 
      for (workDay = MONDAY; workDay <= FRIDAY; 
                             workDay = static_cast<Day>(workDay + 1)) 
      { 
          cout << "Enter the sales for day " 
               << workDay << ": "; 
          cin >> sales[workDay]; 
      } 

      // Calculate the total sales. 
      for (workDay = MONDAY; workDay <= FRIDAY; 
                             workDay = static_cast<Day>(workDay + 1)) 
          total += sales[workDay]; 

      // Display the total. 
      cout << "The total sales are $" << setprecision(2) 
           << fixed << total << endl; 
      return 0; 
  }
  
// =============== Output ===============
// Enter the sales for day 0: 1525.00 [Enter]
// Enter the sales for day 1: 1896.50 [Enter]
// Enter the sales for day 2: 1975.63 [Enter]
// Enter the sales for day 3: 1678.33 [Enter]
// Enter the sales for day 4: 1498.52 [Enter]
// The total sales are $8573.98
// ======================================
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Using Enumerators to Output Values
If you wish to use the enumerator to display a string such as “Monday,” you’ll have to write code that produces the desired string. For example, in the following code, assume `workDay` is a `Day` variable that has been initialized to some value. The `switch` statement displays the name of a day, based upon the value of the variable.
```c++
switch(workDay) {
case MONDAY    : cout << "Monday";
	break;
case TUESDAY   : cout << "Tuesday";
	break;
case WEDNESDAY : cout << "Wednesday";
	break;
case THURSDAY  : cout << "Thursday";
	break;
case FRIDAY    : cout << "Friday";
}
```

## Program 11-12
Shows this type of code used in a function. Instead of asking the user to enter the sales for day 0, day 1, and so forth, it displays the names of the days.
```c++
   // This program demonstrates an enumerated data type.
   #include <iostream>
   #include <iomanip>
   using namespace std;

   enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY };

   // Function prototype
   void displayDayName(Day);

   int main()
   {
       const int NUM_DAYS = 5;       // The number of days
       double sales[NUM_DAYS];       // To hold sales for each day
       double total = 0.0;           // Accumulator
       Day workDay;                  // Loop counter

       // Get the sales for each day.
       for (workDay = MONDAY; workDay <= FRIDAY;
                              workDay = static_cast<Day>(workDay + 1))
       {
           cout << "Enter the sales for day ";
           displayDayName(workDay);
           cout << ": ";
           cin >> sales[workDay];
      }

      // Calculate the total sales.
      for (workDay = MONDAY; workDay <= FRIDAY;
                             workDay = static_cast<Day>(workDay + 1))
           total += sales[workDay];
           
      // Display the total.
      cout << "The total sales are $" << setprecision(2)
           << fixed << total << endl;
           
      return 0;
   }

   //**********************************************************
   // Definition of the displayDayName function               *
   // This function accepts an argument of the Day type and   *
   // displays the corresponding name of the day.             *
   //**********************************************************

   void displayDayName(Day d)
   {
        switch(d)
        {
             case MONDAY    : cout << "Monday";
                              break;
             case TUESDAY   : cout << "Tuesday";
                              break;
             case WEDNESDAY : cout << "Wednesday";
                              break;
             case THURSDAY  : cout << "Thursday";
                              break;
             case FRIDAY    : cout << "Friday";
        }
   }

// =============== Output ===============
// Enter the sales for Monday: 1525.00 [Enter]
// Enter the sales for Tuesday: 1896.50 [Enter]
// Enter the sales for Wednesday: 1975.63 [Enter]
// Enter the sales for Thursday: 1678.33 [Enter]
// Enter the sales for Friday: 1498.52 [Enter]
// The total sales are $8573.98
// ======================================
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Specifying Integer Values for Enumerators
By default, the enumerators in an enumerated data type are assigned the integer values 0, 1, 2, and so forth. If this is not appropriate, you can specify the values to be assigned, as in the following example:
```c++
enum Water { FREEZING = 32, BOILING = 212 };
```

In this example, the `FREEZING` enumerator is assigned the integer value 32, and the `BOILING` enumerator is assigned the integer value 212. [Program 11-13](#Program-11-13) demonstrates how this enumerated type might be used.

## Program 11-13
```c++
    // This program demonstrates an enumerated data type.
    #include <iostream>
    #include <iomanip>
    using namespace std;
    
    int main()
    {
        enum Water { FREEZING = 32, BOILING = 212 };
        int waterTemp; // To hold the water temperature
        cout << "Enter the current water temperature: ";
        cin >> waterTemp;

        if (waterTemp <= FREEZING)
            cout << "The water is frozen.\n";
        else if (waterTemp >= BOILING)
            cout << "The water is boiling.\n";
        else
            cout << "The water is not frozen or boiling.\n";
       return 0;
   }
   
// =============== Example Output 1 ===============
// Enter the current water temperature: 10 [Enter]
// The water is frozen.
// ================================================

// =============== Example Output 2 ===============
// Enter the current water temperature: 300 [Enter]
// The water is boiling.
// ================================================

// =============== Example Output 3 ===============
// Enter the current water temperature: 92 [Enter]
// The water is not frozen or boiling.
// ================================================
```

If you leave out the value assignment for one or more of the enumerators, it will be assigned a default value. Here is an example:
```c++
enum Colors { RED, ORANGE, YELLOW = 9, GREEN, BLUE };
```
In this example, the enumerator `RED` will be assigned the value 0, `ORANGE` will be assigned the value 1, `YELLOW` will be assigned the value 9, `GREEN` will be assigned the value 10, and `BLUE` will be assigned the value 11.

#### [BACK TO THE TOP](#Table-of-Contents)

# Enumerators Must Be Unique within the Same Scope
Enumerators are identifiers just like variable names, named constants, and function names. As with all identifiers, they must be unique within the same scope. For example, an error will result if both of the following enumerated types are declared within the same scope. In the following example, the reason is that `ROOSEVELT` is declared twice.
```c++
enum Presidents { MCKINLEY, ROOSEVELT, TAFT }; enum VicePresidents { ROOSEVELT, FAIRBANKS, SHERMAN }; // Error!
```

The following declarations will also cause an error if they appear within the same scope:
```c++
enum Status { OFF, ON };
const int OFF = 0; // Error!
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Declaring the Type and Defining the Variables in One Statement
The following code uses two lines to declare an enumerated data type and define a variable of the type:
```c++
enum Car { PORSCHE, FERRARI, JAGUAR }; Car sportsCar;
```

C++ allows you to declare an enumerated data type and define one or more variables of the type in the same statement. The previous code could be combined into the following statement:
```c++
enum Car { PORSCHE, FERRARI, JAGUAR } sportsCar;
```

The following statement declares the `Car` data type and defines two variables: `myCar` and `yourCar`.
```c++
enum Car { PORSCHE, FERRARI, JAGUAR } myCar, yourCar;
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Strong Type enums
Earlier, we mentioned that you cannot have multiple enumerators with the same name, within the same scope. In C++ 11 and later, you can use a new type of `enum`, known as a **strongly typed enum** (also known as an `enum class`), to get around this limitation. Here are two examples of a strongly typed `enum` declaration:
```c++
enum class Presidents { MCKINLEY, ROOSEVELT, TAFT }; enum class VicePresidents { ROOSEVELT, FAIRBANKS, SHERMAN };
```

These statements declare two strongly typed `enums`: `Presidents` and `VicePresidents`. Notice they look like regular `enum` declarations, except the word class appears after `enum`. Although both `enums` contain the same enumerator `(ROOSEVELT)`, these declarations will compile without an error.

When you use a strongly typed enumerator, you must prefix the enumerator with the name of the `enum`, followed by the `::` operator. Here are two examples:
```c++
Presidents prez = Presidents::ROOSEVELT; VicePresidents vp = VicePresidents::ROOSEVELT;
```

The first statement defines a Presidents variable named `prez`, and initializes it with the `Presidents::ROOSEVELT` enumerator. The second statement defines a `VicePresidents` variable named `vp`, and initializes it with the `VicePresidents::ROOSEVELT`﻿ enumerator. 
Here is an example of an `if` statement that compares the `prez` variable with an enumerator:
```c++
if (prez == Presidents::ROOSEVELT)    cout << "Roosevelt is president!\n";
```

Strongly typed enumerators are stored as integers like regular enumerators. However, if you want to retrieve a strongly typed enumerator’s underlying integer value, you must use a cast operator. Here is an example:
```c++
int x = static_cast<int>(Presidents::ROOSEVELT);
```

This statement assigns the underlying integer value of the `Presidents::ROOSEVELT` enumerator to the variable x. Here is another example:
```c++
cout << static_cast<int>(Presidents::TAFT) << endl << static_cast<int>(Presidents::MCKINLEY) << endl;
```

This statement displays the integer values for the `Presidents::TAFT` and the `Presidents::MCKINLEY` enumerators.

When you declare a strongly typed `enum`, you can optionally specify any integer data type as the underlying type. You simply write a colon `(:)` after the `enum` name, followed by the desired data type. For example, the following statement declares an `enum` that uses the `char` data type for its enumerators:
```c++
enum class Day : char { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY };
```

The following statement shows another example. This statement declares an `enum` named Water that uses `unsigned` as the data type of its enumerators. Additionally, values are assigned to the enumerators.
```c++
enum class Water : unsigned { FREEZING = 32, BOILING = 212 };
```

#### [BACK TO THE TOP](#Table-of-Contents)
***
# [Programming Project](!%20Unit%2011%20Answers.md#Programming-Project)
[Table of Contents](/README.md) | [Previous Section](11.11%20-%20Focus%20on%20Software%20Engineering.md) | [Next Section (Next Chapter)](../../Module%205/Pearson%20Notes/12.1%20-%20File%20Operations.md) | [All Sections](/Module%204/Pearson%20Notes/)