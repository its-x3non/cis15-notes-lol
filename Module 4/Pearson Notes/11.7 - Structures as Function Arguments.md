[Table of Contents](/README.md) | [Previous Section](11.6%20-%20Focus%20on%20Software%20Engineering%20-%20Nested%20Structures.md) | [Next Section](11.8%20-%20Returning%20a%20Structure%20from%20a%20Function.md) | [All Sections](/Module%204/Pearson%20Notes/)<br />

-----
#Module4 #PearsonNotes 
# 11.7 - Structures as Function Arguments
Like other variables, the individual members of a structure variable may be used as function arguments. For example, assume the following structure declaration exists in a program:
```c++
struct Rectangle
{
	double length;
	double width;
	double area;
}
```

Let's say the following function definition exists in the same program:
```c++
double multiply(double x, double y)
{
	return x*y;
}
```

Assuming `box` is a variable of the `Rectangle` structure type, the following function call will pass `box.length` into `x` and `box.width` into `y`. The return value will be stored in `box.area`.
```c++
box.area = multiple(box.length, box.width);
```

Sometimes it's more convenient to pass an entire structure variable into a function instead of individual members. For example, the following function definition uses a `Rectangle` structure variable as its parameter:
```c++
void showRect (Rectangle r)
{
	cout << r.length << endl;
	cout << r.width << endl;
	cout << r.area << endl;
}
```

The following function call passes the `box` variable into `r`:
```c++
showRect(box);
```
Inside the function `showRect`, `r`'s members contain a copy of `box`'s members. This is illustrated in [Figure 11-3](#Figure-11-3).

### Figure 11-3
Passing a structure variable to a Function <br />
![11.7 - Figure 11-3.png](11.7%20Photos/11.7%20-%20Figure%2011-3.png)

Once the function is called, `r.length` contains a copy of `box.length`, `r.width` contains a copy of `box.width`, and `r.area` contains a copy of `box.area`.

Structures, like all variables, are normally passed by value into a function. For example, [Program 11-6](#Program-11-6).

## Program 11-6
This program uses 2 functions that accept structures as arguments. Arguments are passed to the `getItem` function by reference, and to the `showItem` function by value.
```c++
  // This program has functions that accept structure variables 
  // as arguments. 
  #include <iostream> 
  #include <string> 
  #include <iomanip> 
  using namespace std; 

  struct InventoryItem 
  {
      int partNum;                // Part number
      string description;         // Item description
      int onHand;                 // Units on hand
      double price;               // Unit price
  };

  // Function Prototypes
  void getItem(InventoryItem&);   // Argument passed by reference
  void showItem(InventoryItem);   // Argument passed by value
 
  int main()
  {
      InventoryItem part;
      getItem(part);
      showItem(part);
      
      return 0;
  }
  
//************************************************************
// Definition of function getItem. This function uses        *
// a structure reference variable as its parameter. It asks  *
// the user for information to store in the structure.       *
//************************************************************

  void getItem(InventoryItem &p)  // Uses a reference parameter
  {
      // Get the part number.
      cout << "Enter the part number: ";
      cin >> p.partNum;
      
      // Get the part description.
      cout << "Enter the part description: ";
      cin.ignore();  // Ignore the remaining newline character
      getline(cin, p.description);

      // Get the quantity on hand.
      cout << "Enter the quantity on hand: ";
      cin >> p.onHand;

      // Get the unit price.
      cout << "Enter the unit price: ";
      cin >> p.price;
  }

  //***********************************************************
  // Definition of function showItem. This function accepts   *
  // an argument of the InventoryItem structure type. The     *
  // contents of the structure is displayed.                  *
  //***********************************************************

  void showItem(InventoryItem p)
  {
      cout << fixed << showpoint << setprecision(2);
      cout << "Part Number: " << p.partNum << endl;
      cout << "Description: " << p.description << endl;
      cout << "Units On Hand: " << p.onHand << endl;
      cout << "Price: $" << p.price << endl;
  }
// =============== Output ===============
// Enter the part number: 800 [Enter]
// Enter the part description: Screwdriver [Enter]
// Enter the quantity on hand: 135 [Enter]
// Enter the unit price: 1.25 [Enter]
// Part Number: 800
// Description: Screwdriver
// Units on Hand: 135
// Price: $1.25
// ======================================
```

Notice the `InventoryItem` structure declaration appears before both the prototypes and the definitions of the `getItem` and `showItem` functions. This is because both functions use an `InventoryItem` structure variable as their parameter. The complier must know what `InventoryItem` is before it encounters any definitions for variables of that type. Otherwise, an error will occur.

# Constant Reference Parameters
Sometimes structures can be quite large. Passing large structures by value can decrease a program’s performance because a copy of the structure has to be created. When a structure is passed by reference, however, it isn’t copied. A reference that points to the original argument is passed instead. So, it’s often preferable to pass large objects such as structures by reference.

Of course, the disadvantage of passing an object by reference is that the function has access to the original argument. It can potentially alter the argument’s value. This can be prevented, however, by passing the argument as a constant reference. The `showItem` function from  [Program 11-6](#Program-11-6) is shown here:
```c++
void showItem(const InventoryItem &p)       
{
	cout << fixed << showpoint << setprecision(2);
	cout << "Part Number: " << p.partNum << endl;
	cout << "Description: " << p.description << endl;
	cout << "Units on Hand: " << p.onHand << endl;
	cout << "Price: $" << p.price << endl;
}
```
This is modified to use a constant reference parameter.

This version of the function is more efficient than the original version because the amount of time and memory consumed in the function call is reduced. Because the parameter is defined as a constant, the function cannot accidently corrupt the value of the argument.
The prototype for this version of the function is as follows:
```c++
void showItem(const InventoryItem&);
```

-----
# [Quiz for This Section](!%20Unit%2011%20Answers.md#Quiz-11.7)
[Table of Contents](/README.md) | [Previous Section](11.6%20-%20Focus%20on%20Software%20Engineering%20-%20Nested%20Structures.md) | [Next Section](11.8%20-%20Returning%20a%20Structure%20from%20a%20Function.md) | [All Sections](/Module%204/Pearson%20Notes/)<br />