[Table of Contents](/README.md) | [Previous Section (Go to Previous Chapter)](../../Module%206/Pearson%20Notes/13.16%20-%20Focus%20on%20Object-Oriented%20Design.md) | [Next Section](14.2%20-%20Friends%20of%20Classes.md)| [All Sections](/Module%207/Pearson%20Notes/)
***
#Module7 #PearsonNotes <br />
# 14.1 - Instance and Static Members
## Instance Variables
Each class object (an instance of a class) has its own copy of the class’s member variables. An object’s member variables are separate and distinct from the member variables of other objects of the same class. For example, recall that the `Rectangle` class discussed in [Chapter 13](/Module%206/Pearson%20Notes) has two member variables: `width` and `length`. Suppose we define two objects of the Rectangle class and set their width and length member variables as shown in the following code.
```c++
Rectangle box1, box2;

// Set the width and length for box1.
box1.setWidth(5);
box1.setLength(10);

// Set the width and length for box2.
box2.setWidth(500);
box2.setLength(1000);
```
This code creates box1 and box2, which are two distinct objects. This is shown in Figure 14-1.

### Figure 14-1
Two Objects
| box1 object | .   | .   | box2 object | .   | .   |
| ----------- | --- | --- | ----------- | --- | --- |
| width       | 5    |     | width            | 500    |     |
| length            |10     |     | length             | 1000    |     |
When the `getWidth` member function is called, it returns the value stored in the calling object’s `width` member variable. For example, the following statement displays `5` `500`.
```c++
cout << box1.getWidth() << " " << box2.getWidth() << endl;
```

In object-oriented programming, member variables such as the `Rectangle` class’s `width` and `length` members are known as **instance variables**. They are called instance variables because each instance of the class has its own copies of the variables.

# Static Members
It is possible to create a member variable or member function that does not belong to any instance of a class. Such members are known as **static member variables** and **static member functions**. When a value is stored in a static member variable, it is not stored in an instance of the class. In fact, an instance of the class doesn’t even have to exist in order for values to be stored in the class’s static member variables. Likewise, static member functions do not operate on instance variables. Instead, they can operate only on static member variables. You can think of static member variables and static member functions as belonging to the class instead of to an instance of the class. In this section, we will take a closer look at static members. First, we will examine static member variables.

# Static Member Variables
When a member variable is declared with the key word `static`, there will be only one copy of the member variable in memory, regardless of the number of instances of the class that might exist. A single copy of a class’s static member variable is shared by all instances of the class. 

#### Contents of `Tree.h`
```c++
  // Tree class
  class Tree
  {
  private:
    static int objectCount;    // Static member variable.
  public:
      // Constructor
      Tree()
         { objectCount++; }

      // Accessor function for objectCount
      int getObjectCount() const
         { return objectCount; }
  };

  // Definition of the static member variable, written
  // outside the class.
  int Tree::objectCount = 0;
```
First, notice in line 5 the declaration of the static member variable named `objectCount`: A static member variable is created by placing the key word static before the variable’s data type. Also notice in line 18, we have written a definition statement for the `objectCount` variable, and that the statement is outside the class declaration. This external definition statement causes the variable to be created in memory, and is required. In line 18, we have explicitly initialized the `objectCount` variable with the value 0. We could have left out the initialization because C++ automatically stores 0 in all uninitialized static member variables. It is a good practice to initialize the variable anyway, so it is clear to anyone reading the code that the variable starts out with the value 0.

Next, look at the constructor in lines 8 and 9. In line 9, the ++ operator is used to increment `objectCount`. Each time an instance of the Tree class is created, the constructor will be called, and the `objectCount` member variable will be incremented. As a result, the `objectCount` member variable will contain the number of instances of the Tree class that have been created. The `getObjectCount` function, in lines 12 and 13, returns the value in `objectCount`. 

***
# Quiz for This Section
[Table of Contents](/README.md) | [Previous Section (Go to Previous Chapter)](../../Module%206/Pearson%20Notes/13.16%20-%20Focus%20on%20Object-Oriented%20Design.md) | [Next Section](14.2%20-%20Friends%20of%20Classes.md)| [All Sections](/Module%207/Pearson%20Notes/)