[Table of Contents](/README.md) | [Previous Section](14.4%20-%20Copy%20Constructors.md) | [Next Section](14.6%20-%20Object%20Conversion.md) | [All Sections](/Module%207/Pearson%20Notes/)
***
#Module7 #PearsonNotes <br />
### Since this is a long section here are a table of contents for each section (In Order):
#### Table of Contents
- 14.5 - Operator Overloading
- [The `this` Pointer](#The-this-Pointer)
- [Overloading the `=` Operator](#Overloading-the-=-Operator)
	- [Checking for Self-Assignment](#Checking-for-Self-Assignment)
- [The `=` Operator's Return Value](#The-=-Operator's-Return-Value)
	- [Copy Assignment](Copy-Assignment)
- [Some General Issues of Operator Overloading](#Some-General-Issues-of-Operator-Overloading)
- [Overloading Math Operators](#Overloading-Math-Operators)
- [Overloading the Prefix `++` Operator](#Overloading-the-Prefix-++-Operator)
- [Overloading the Postfix `++` Operator](#Overloading-the-Postfix-++-Operator)
- [Overloading Relational Operators](#Overloading-Relational-Operators)
- [Overloading the `<<` and `>>` Operators](#Overloading-the-<<-and->>-Operators)
- Overloading the `[]` Operator
***
# 14.5 - Operator Overloading
C++ provides many operators to manipulate data of the primitive data types. However, what if you wish to use an operator to manipulate class objects? For example, assume that a class named `Date` exists, and objects of the `Date` class hold the month, day, and year in member variables. Suppose the `Date` class has a member function named `add`. The `add` member function adds a number of days to the `date` and adjusts the member variables if the date goes to another month or year. For example, the following statement adds 5 days to the date stored in the today `object`:
```c++
today.add(5);
```
Although it might be obvious that the statement is adding 5 days to the date stored in `today`, the use of an operator might be more intuitive. For example, look at the following statement:
```c++
today += 5;
```
This statement uses the standard `+=`﻿ operator to add 5 to `today`. This behavior does not happen automatically, however. The `+=` operator must be `overloaded` for this action to occur. In this section, you will learn to overload many of C++’s operators to perform specialized operations on class objects.

**NOTE:** You have already experienced the behavior of an overloaded operator. The `/` operator performs two types of division: floating-point and integer. If one of the `/` ­operator’s operands is a floating-point type, the result will be a floating-point value. If both of the `/` operator’s operands are integers, however, a different behavior occurs: the result is an integer, and any fractional part is thrown away.

#### [BACK TO THE TOP](#Table-of-Contents)

# The `this` Pointer
Before going any further with our discussion of operator overloading, we need to discuss a special pointer named this. The **this pointer** is a built-in pointer that every class has. It is passed as a hidden argument to all nonstatic member functions, and it always points to the instance of the class making the function call. For example, if `student1` and `student2` are both `StudentTestScores` objects, the following statement causes the `getStudentName` member function to operate on `student1`:
```c++
cout << student1.getStudentName() << endl;
```
Likewise, the following statement causes `getStudentName` to operate on `student2`:
```c++
cout << student2.getStudentName() << endl;
```
When `getStudentName` is operating on `student1`, the this pointer is pointing to student1. When `getStudentName` is operating on `student2`, the `this` pointer is pointing to `student2`. The `this` pointer always points to the object that is being used to call the member function.

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading the `=` Operator
Although copy constructors solve the initialization problems inherent with objects containing pointer members, they do not work with simple assignment statements. Copy constructors are just that- constructors. They are invoked only when an object is created. Statements like the following still perform memberwise assignment:
```c++
student2 = student1
```
In order to change the way the assignment operator works, it must be overloaded. Operator overloading permits you to redefine an existing operator’s behavior when used with a class object.

C++ allows a class to have special member functions called **operator functions**. If you wish to redefine the way a particular operator works with an object, you define a function for that operator. The operator function is then executed any time the operator is used with an object of that class. Let’s look at how we might overload the = operator in the `StudentTestScores` class. Within `StudentTestScores.h` class (v3), you can find that inside the class the following member function:
```c++
 // Overloaded = operator
 const StudentTestScores operator=(const StudentTestScores &right)
 {  if (this != &right)
    {
       delete[] testScores;
       studentName = right.studentName;
       numTestScores = right.numTestScores;
       testScores = new double[numTestScores];
       for (int i = 0; i < numTestScores; i++)
          testScores[i] = right.testScores[i];
     }
     return *this;
 }
```

### Figure 14-5
Function Header for `operator=` <br />
![Figure 14-5](14.5%20Photos/14.5%20-%20Figure%2014-5.png) <br />
- **Return type:** The function’s return type is `const StudentTestScores`. This means that it returns a `StudentTestScores` object that is `const` (it cannot be modified). We will discuss this in greater detail in a moment.
- **Function name:** The function’s name is `operator=`. This specifies that the function overloads the `=` operator. Because it is a member of the `StudentTestScores` class, this function will be called when an assignment statement executes where the object on the left side of the `=` operator is a `StudentTestScores` object.
- **Parameter declaration:** The function has one parameter: a constant reference object named `right`. This parameter references the object on the right side of the operator. For example, when the following statement is executed, right will reference the `student1` object: 
```c++
student 2 = student1;
```

We declared the `right` parameter as a reference variable for efficiency purposes. This prevents the compiler from making a copy of the object that is being passed into the function. We declared it `const`, so the function will not accidentally change its contents.

***
**NOTE:** In the example, the parameter was named right simply to illustrate that it references the object on the right side of the operator. You can name the parameter anything you wish. It will always take the object on the operator’s right as its argument.
***

In learning the mechanics of operator overloading, it is helpful to know that the following two statements do the same thing:
```c++
student2 = student1;             // Call operator= function
student2.operator=(student1);    // Call operator= function
```
In the second statement, you can see exactly what is going on in the function call. The `student1` object is being passed to the function’s parameter, `right`. Inside the function, the values in `right`’s members are used to initialize `student2`. Notice the `operator=` ﻿function has access to the `right` parameter’s private members. Because the `operator=` function is a member of the `StudentTestScores` class, it has access to the private members of any `StudentTestScores` object that is passed into it.

## Checking for Self-Assignment
### Figure 14-6
The `this` pointer and the `right` parameter. <br />
![Figure 14-6](14.5%20Photos/14.5%20-%20Figure%2014-6.png)
Recall that `this` is a hidden argument that is passed to all nonstatic member functions. `this` is a special pointer that points to the object that called the function. Inside our `operator=` function, this will point to the object that is on the left side of the `=` sign, and `right` will reference the object on the right side of the `=` sign.  In the figure, assume that `student1` and `student2` are both `StudentTestScores` objects.

Look back at the `operator=` function, and notice the first statement inside the body of the function (line 64) is an `if` statement that starts like this:
```c++
if(this != &right)
```
This `if` statement is making sure the address stored in `this` is not the same as the address of the `right` object. In other words, it is checking for self-assignment. Self-assignment occurs when you assign an object to itself. For example, assume `student1` is a `StudentTestScores` object, and it holds a set of test scores. The following statement performs self-assignment:
```c++
student1 = student1;
```

Obviously, there is no reason to write a statement like this, but, in programs that work with pointers and references to objects, such assignments can happen in a roundabout way. It is important that you write code in your `operator=` functions to check for self-assignment, especially in classes that dynamically allocate memory. For example, the following code fragment shows how the `operator=` member function of the `StudentTestScores` class would look if we did not check for self-assignment:
```c++
// Overloaded = operator that does not check for self-assignment
const StudentTestScores operator=(const StudentTestScores & right) {
    delete[] testScores;
     studentName = right.studentName;
     numTestScores = right.numTestScores;
     testScores = new double[numTestScores];
     for  (int i = 0; i < numTestScores; i++)        testScores[i] = right.testScores[i];
     return * this;
}
```

In this version of the function, the first thing we do is delete the memory for the ­`testScores` array. In the event of self-assignment, this will be a problem because we are deleting the memory from which we will be copying! Obviously, the assignment will not work as intended. The corrected version of the function, shown again here, avoids the problem by skipping all of the assignment steps when self-assignment has been detected:
```c++
 // Overloaded = operator
 const StudentTestScores operator=(const StudentTestScores &right)
 {  if (this != &right)
    {
       delete[] testScores;
       studentName = right.studentName;
       numTestScores = right.numTestScores;
       testScores = new double[numTestScores];
       for  (int i = 0; i < numTestScores; i++)
           testScores[i] = right.testScores[i];
    }
    return *this;
 }
```

#### [BACK TO THE TOP](#Table-of-Contents)

# The `=` Operator's Return Value
The last thing we need to discuss about the operator= function is its return value. Recall that C++’s built-in `=` operator allows multiple assignment statements such as:
```c++
a = b = c = d;
```
- The expression `c = d` assigns `d`﻿ to `c`, then returns the new value of `c`.
- The new value of `c`, which is returned from the previous expression is assigned to `b`, then the new value of `b` is returned.
- The new value of `b`, which is returned from the previous expression, is assigned to `a`.

If a class object’s overloaded `=` operator is to function this way, it too must return the value of the object that received the assignment. That’s why the operator `=` function in the `StudentTestScores` class has a return type of `const StudentTestScores`, and the last statement in the function is:
```c++
return *this;
```
The expression `*this` dereferences the `this` pointer, giving us the actual object that received the assignment. A `const` copy of that object is then returned.

## Copy Assignment
The overloaded `=` operator that we just looked at is an example of a **copy assignment operator**. It is called a copy assignment operator because it copies data from one object to another. Later in this chapter, you will see an example of another type of assignment known as *move assignment*.

### Program 14-6
Demonstrates the `StudentTestScores` Class with its overloaded assignment operator.
```c++
// This program demonstrates the overloaded = operator
#include <iostream>
#include "StudentTestScores.h"
using namespace std;

// Function prototype
void displayStudent(StudentTestScores);

int main()
{
   // Create a StudentTestScores object and
   // assign test scores.
   StudentTestScores student1("Kelly Thorton", 3);
   student1.setTestScore(100.0, 0);
   student1.setTestScore(95.0, 1);
   student1.setTestScore(80, 2);
   
   // Create another StudentTestScore object
   // with default test scores.
   StudentTestScores student2("Jimmy Griffin", 5);

   // Assign the student1 object to student2
   student2 = student1;
   
   // Display both objects. They should
   // contain the same data.
   displayStudent(student1);
   displayStudent(student2);
   return 0;
}

// The displayStudent function accepts a
// StudentTestScores object's data.
void displayStudent(StudentTestScores s)
{
   cout << "Name: " << s.getStudentName() << endl;
   cout << "Test Scores: ";
   for (int i = 0; i < s.getNumTestScores(); i++)
       cout << s.getTestScore(i) << " ";
   cout << endl;
}

// ========== Output ===========
// Name: Kelly Thorton
// Test Scores: 100 95 80
// Name: Kelly Thorton
// Test Scores: 100 95 80
// ==============================
```

### Program 14-7
The overloaded `=` operator function is demonstrated again here. The multiple assignment statement in line 22 causes the `operator=` function to execute.
```c++
// This program demonstrates the overloaded = operator returning a value.
#include <iostream>
#include "StudentTestScores.h"
using namespace std;

// Function prototype
void displayStudent(StudentTestScores);

int main()
{
   // Create a StudentTestScores object.
   StudentTestScores student1("Kelly Thorton", 3);
   student1.setTestScore(100.0, 0);
   student1.setTestScore(95.0, 1);
   student1.setTestScore(80, 2);

   // Create two more StudentTestScores objects.
   StudentTestScores student2("Jimmy Griffin", 5);
   StudentTestScores student3("Kristen Lee", 10);

   // Assign student1 to student2 and student3.
   student3 = student2 = student1;

   // Display the objects.
   displayStudent(student1);
   displayStudent(student2);
   displayStudent(student3);
   return 0;
}

// displayStudent function
void displayStudent(StudentTestScores s)
{
   cout << "Name: " << s.getStudentName() << endl;
   cout << "Test Scores: ";
   for (int i = 0; i < s.getNumTestScores(); i++)
       cout << s.getTestScore(i) << " ";
   cout << endl;
}

// ========== Output ===========
// Name: Kelly Thorton
// Test Scores: 100 95 80
// Name: Kelly Thorton
// Test Scores: 100 95 80
// Name: Kelly Thorton
// Test Scores: 100 95 80
// ==============================
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Some General Issues of Operator Overloading
Now that you have had a taste of operator overloading, let’s look at some of the general issues involved in this programming technique.

Although it is not a good programming practice, you can change an operator’s entire meaning if that’s what you wish to do. There is nothing to prevent you from changing the `=` symbol from an assignment operator to a “display” operator. For instance, the following class does just that:
```c++
class Weird {
 private:
  int value;
 public:
  Weird(int v) { value = v; }
  void operator=(const weird &right) const { cout << right.value << endl; }
};
```
Although the `operator=` function in the Weird class overloads the assignment operator, the function doesn’t perform an assignment. Instead, it displays the contents of `right.value`. 

Consider the following program segment:
```c++
Weird a(5), b(10);
a = b;
```
Although the statement `a = b` looks like an assignment statement, it actually causes the contents of b’s value member to be displayed on the screen:
```c++
10
```
Another operator overloading issue is you cannot change the number of operands taken by an operator. The `=` symbol must always be a binary operator. Likewise, `++` and `−−` must always be unary operators.

## Table 14-1
Operators that May be Overloaded
| `+`   | `-`  | `*`   | `/`   | `%`  | `^`   |
| ----- | ---- | ----- | ----- | ---- | ----- |
| `&`   | \|  | `~`   | `!`   | `=`  | `<`   |
| `>`   | `+=` | `-=`  | `*=`  | `/=` | `%=`  |
| `^=`  | `&=`   | \|=  | `<<`  | `>>` | `>>=` |
| `<<=` | `==` | `!=`  | `<=`  | `>=` | `&&`  |
| \| \|  | `++` | `--`  | `-<*` | `,`  | `-<`  |
| `[]`  | `()` | `new` | `delete`      |      |       |

The only operators that cannot be overloaded:
| `?:` | `.` | `.*` | `::` | `sizeof` |
| ---- | --- | ---- | ---- | -------- |

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading Math Operators

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading the Prefix `++` Operator

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading the Postfix `++` Operator

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading Relational Operators

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading the `<<` and `>>` Operators

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading the `[]` Operator

#### [BACK TO THE TOP](#Table-of-Contents)

***
# Quiz for This Section
[Table of Contents](/README.md) | [Previous Section](14.4%20-%20Copy%20Constructors.md) | [Next Section](14.6%20-%20Object%20Conversion.md) | [All Sections](/Module%207/Pearson%20Notes/)