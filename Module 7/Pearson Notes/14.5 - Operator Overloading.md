[Table of Contents](/README.md) | [Previous Section](14.4%20-%20Copy%20Constructors.md) | [Next Section](14.6%20-%20Object%20Conversion.md) | [All Sections](/Module%207/Pearson%20Notes/)
***
#Module7 #PearsonNotes <br />
### Since this is a long section here are a table of contents for each section (In Order):
#### Table of Contents
- 14.5 - Operator Overloading
- [The `this` Pointer](#The-this-Pointer)
- [Overloading the `=` Operator](#Overloading-the-=-Operator)
	- [Checking for Self-Assignment](#Checking-for-Self-Assignment)
- [The `=` Operator's Return Value](#The-=-Operator's-Return-Value)
	- [Copy Assignment](Copy-Assignment)
- [Some General Issues of Operator Overloading](#Some-General-Issues-of-Operator-Overloading)
- [Overloading Math Operators](#Overloading-Math-Operators)
- [Overloading the Prefix `++` Operator](#Overloading-the-Prefix-++-Operator)
- [Overloading the Postfix `++` Operator](#Overloading-the-Postfix-++-Operator)
- [Overloading Relational Operators](#Overloading-Relational-Operators)
- [Overloading the `<<` and `>>` Operators](#Overloading-the-<<-and->>-Operators)
- [Overloading the Subscript Operator](#Overloading-the-Subscript-Operator)
***
# 14.5 - Operator Overloading
C++ provides many operators to manipulate data of the primitive data types. However, what if you wish to use an operator to manipulate class objects? For example, assume that a class named `Date` exists, and objects of the `Date` class hold the month, day, and year in member variables. Suppose the `Date` class has a member function named `add`. The `add` member function adds a number of days to the `date` and adjusts the member variables if the date goes to another month or year. For example, the following statement adds 5 days to the date stored in the today `object`:
```c++
today.add(5);
```
Although it might be obvious that the statement is adding 5 days to the date stored in `today`, the use of an operator might be more intuitive. For example, look at the following statement:
```c++
today += 5;
```
This statement uses the standard `+=`﻿ operator to add 5 to `today`. This behavior does not happen automatically, however. The `+=` operator must be `overloaded` for this action to occur. In this section, you will learn to overload many of C++’s operators to perform specialized operations on class objects.

**NOTE:** You have already experienced the behavior of an overloaded operator. The `/` operator performs two types of division: floating-point and integer. If one of the `/` ­operator’s operands is a floating-point type, the result will be a floating-point value. If both of the `/` operator’s operands are integers, however, a different behavior occurs: the result is an integer, and any fractional part is thrown away.

#### [BACK TO THE TOP](#Table-of-Contents)

# The `this` Pointer
Before going any further with our discussion of operator overloading, we need to discuss a special pointer named this. The **this pointer** is a built-in pointer that every class has. It is passed as a hidden argument to all nonstatic member functions, and it always points to the instance of the class making the function call. For example, if `student1` and `student2` are both `StudentTestScores` objects, the following statement causes the `getStudentName` member function to operate on `student1`:
```c++
cout << student1.getStudentName() << endl;
```
Likewise, the following statement causes `getStudentName` to operate on `student2`:
```c++
cout << student2.getStudentName() << endl;
```
When `getStudentName` is operating on `student1`, the this pointer is pointing to student1. When `getStudentName` is operating on `student2`, the `this` pointer is pointing to `student2`. The `this` pointer always points to the object that is being used to call the member function.

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading the `=` Operator
Although copy constructors solve the initialization problems inherent with objects containing pointer members, they do not work with simple assignment statements. Copy constructors are just that- constructors. They are invoked only when an object is created. Statements like the following still perform memberwise assignment:
```c++
student2 = student1
```
In order to change the way the assignment operator works, it must be overloaded. Operator overloading permits you to redefine an existing operator’s behavior when used with a class object.

C++ allows a class to have special member functions called **operator functions**. If you wish to redefine the way a particular operator works with an object, you define a function for that operator. The operator function is then executed any time the operator is used with an object of that class. Let’s look at how we might overload the = operator in the `StudentTestScores` class. Within `StudentTestScores.h` class (v3), you can find that inside the class the following member function:
```c++
 // Overloaded = operator
 const StudentTestScores operator=(const StudentTestScores &right)
 {  if (this != &right)
    {
       delete[] testScores;
       studentName = right.studentName;
       numTestScores = right.numTestScores;
       testScores = new double[numTestScores];
       for (int i = 0; i < numTestScores; i++)
          testScores[i] = right.testScores[i];
     }
     return *this;
 }
```

### Figure 14-5
Function Header for `operator=` <br />
![Figure 14-5](14.5%20Photos/14.5%20-%20Figure%2014-5.png) <br />
- **Return type:** The function’s return type is `const StudentTestScores`. This means that it returns a `StudentTestScores` object that is `const` (it cannot be modified). We will discuss this in greater detail in a moment.
- **Function name:** The function’s name is `operator=`. This specifies that the function overloads the `=` operator. Because it is a member of the `StudentTestScores` class, this function will be called when an assignment statement executes where the object on the left side of the `=` operator is a `StudentTestScores` object.
- **Parameter declaration:** The function has one parameter: a constant reference object named `right`. This parameter references the object on the right side of the operator. For example, when the following statement is executed, right will reference the `student1` object: 
```c++
student 2 = student1;
```

We declared the `right` parameter as a reference variable for efficiency purposes. This prevents the compiler from making a copy of the object that is being passed into the function. We declared it `const`, so the function will not accidentally change its contents.

***
**NOTE:** In the example, the parameter was named right simply to illustrate that it references the object on the right side of the operator. You can name the parameter anything you wish. It will always take the object on the operator’s right as its argument.
***

In learning the mechanics of operator overloading, it is helpful to know that the following two statements do the same thing:
```c++
student2 = student1;             // Call operator= function
student2.operator=(student1);    // Call operator= function
```
In the second statement, you can see exactly what is going on in the function call. The `student1` object is being passed to the function’s parameter, `right`. Inside the function, the values in `right`’s members are used to initialize `student2`. Notice the `operator=` ﻿function has access to the `right` parameter’s private members. Because the `operator=` function is a member of the `StudentTestScores` class, it has access to the private members of any `StudentTestScores` object that is passed into it.

## Checking for Self-Assignment
### Figure 14-6
The `this` pointer and the `right` parameter. <br />
![Figure 14-6](14.5%20Photos/14.5%20-%20Figure%2014-6.png)
Recall that `this` is a hidden argument that is passed to all nonstatic member functions. `this` is a special pointer that points to the object that called the function. Inside our `operator=` function, this will point to the object that is on the left side of the `=` sign, and `right` will reference the object on the right side of the `=` sign.  In the figure, assume that `student1` and `student2` are both `StudentTestScores` objects.

Look back at the `operator=` function, and notice the first statement inside the body of the function (line 64) is an `if` statement that starts like this:
```c++
if(this != &right)
```
This `if` statement is making sure the address stored in `this` is not the same as the address of the `right` object. In other words, it is checking for self-assignment. Self-assignment occurs when you assign an object to itself. For example, assume `student1` is a `StudentTestScores` object, and it holds a set of test scores. The following statement performs self-assignment:
```c++
student1 = student1;
```

Obviously, there is no reason to write a statement like this, but, in programs that work with pointers and references to objects, such assignments can happen in a roundabout way. It is important that you write code in your `operator=` functions to check for self-assignment, especially in classes that dynamically allocate memory. For example, the following code fragment shows how the `operator=` member function of the `StudentTestScores` class would look if we did not check for self-assignment:
```c++
// Overloaded = operator that does not check for self-assignment
const StudentTestScores operator=(const StudentTestScores & right) {
    delete[] testScores;
     studentName = right.studentName;
     numTestScores = right.numTestScores;
     testScores = new double[numTestScores];
     for  (int i = 0; i < numTestScores; i++)        testScores[i] = right.testScores[i];
     return * this;
}
```

In this version of the function, the first thing we do is delete the memory for the ­`testScores` array. In the event of self-assignment, this will be a problem because we are deleting the memory from which we will be copying! Obviously, the assignment will not work as intended. The corrected version of the function, shown again here, avoids the problem by skipping all of the assignment steps when self-assignment has been detected:
```c++
 // Overloaded = operator
 const StudentTestScores operator=(const StudentTestScores &right)
 {  if (this != &right)
    {
       delete[] testScores;
       studentName = right.studentName;
       numTestScores = right.numTestScores;
       testScores = new double[numTestScores];
       for  (int i = 0; i < numTestScores; i++)
           testScores[i] = right.testScores[i];
    }
    return *this;
 }
```

#### [BACK TO THE TOP](#Table-of-Contents)

# The `=` Operator's Return Value
The last thing we need to discuss about the operator= function is its return value. Recall that C++’s built-in `=` operator allows multiple assignment statements such as:
```c++
a = b = c = d;
```
- The expression `c = d` assigns `d`﻿ to `c`, then returns the new value of `c`.
- The new value of `c`, which is returned from the previous expression is assigned to `b`, then the new value of `b` is returned.
- The new value of `b`, which is returned from the previous expression, is assigned to `a`.

If a class object’s overloaded `=` operator is to function this way, it too must return the value of the object that received the assignment. That’s why the operator `=` function in the `StudentTestScores` class has a return type of `const StudentTestScores`, and the last statement in the function is:
```c++
return *this;
```
The expression `*this` dereferences the `this` pointer, giving us the actual object that received the assignment. A `const` copy of that object is then returned.

## Copy Assignment
The overloaded `=` operator that we just looked at is an example of a **copy assignment operator**. It is called a copy assignment operator because it copies data from one object to another. Later in this chapter, you will see an example of another type of assignment known as *move assignment*.

### Program 14-6
Demonstrates the `StudentTestScores` Class with its overloaded assignment operator.
```c++
// This program demonstrates the overloaded = operator
#include <iostream>
#include "StudentTestScores.h"
using namespace std;

// Function prototype
void displayStudent(StudentTestScores);

int main()
{
   // Create a StudentTestScores object and
   // assign test scores.
   StudentTestScores student1("Kelly Thorton", 3);
   student1.setTestScore(100.0, 0);
   student1.setTestScore(95.0, 1);
   student1.setTestScore(80, 2);
   
   // Create another StudentTestScore object
   // with default test scores.
   StudentTestScores student2("Jimmy Griffin", 5);

   // Assign the student1 object to student2
   student2 = student1;
   
   // Display both objects. They should
   // contain the same data.
   displayStudent(student1);
   displayStudent(student2);
   return 0;
}

// The displayStudent function accepts a
// StudentTestScores object's data.
void displayStudent(StudentTestScores s)
{
   cout << "Name: " << s.getStudentName() << endl;
   cout << "Test Scores: ";
   for (int i = 0; i < s.getNumTestScores(); i++)
       cout << s.getTestScore(i) << " ";
   cout << endl;
}

// ========== Output ===========
// Name: Kelly Thorton
// Test Scores: 100 95 80
// Name: Kelly Thorton
// Test Scores: 100 95 80
// ==============================
```

### Program 14-7
The overloaded `=` operator function is demonstrated again here. The multiple assignment statement in line 22 causes the `operator=` function to execute.
```c++
// This program demonstrates the overloaded = operator returning a value.
#include <iostream>
#include "StudentTestScores.h"
using namespace std;

// Function prototype
void displayStudent(StudentTestScores);

int main()
{
   // Create a StudentTestScores object.
   StudentTestScores student1("Kelly Thorton", 3);
   student1.setTestScore(100.0, 0);
   student1.setTestScore(95.0, 1);
   student1.setTestScore(80, 2);

   // Create two more StudentTestScores objects.
   StudentTestScores student2("Jimmy Griffin", 5);
   StudentTestScores student3("Kristen Lee", 10);

   // Assign student1 to student2 and student3.
   student3 = student2 = student1;

   // Display the objects.
   displayStudent(student1);
   displayStudent(student2);
   displayStudent(student3);
   return 0;
}

// displayStudent function
void displayStudent(StudentTestScores s)
{
   cout << "Name: " << s.getStudentName() << endl;
   cout << "Test Scores: ";
   for (int i = 0; i < s.getNumTestScores(); i++)
       cout << s.getTestScore(i) << " ";
   cout << endl;
}

// ========== Output ===========
// Name: Kelly Thorton
// Test Scores: 100 95 80
// Name: Kelly Thorton
// Test Scores: 100 95 80
// Name: Kelly Thorton
// Test Scores: 100 95 80
// ==============================
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Some General Issues of Operator Overloading
Now that you have had a taste of operator overloading, let’s look at some of the general issues involved in this programming technique.

Although it is not a good programming practice, you can change an operator’s entire meaning if that’s what you wish to do. There is nothing to prevent you from changing the `=` symbol from an assignment operator to a “display” operator. For instance, the following class does just that:
```c++
class Weird {
 private:
  int value;
 public:
  Weird(int v) { value = v; }
  void operator=(const weird &right) const { cout << right.value << endl; }
};
```
Although the `operator=` function in the Weird class overloads the assignment operator, the function doesn’t perform an assignment. Instead, it displays the contents of `right.value`. 

Consider the following program segment:
```c++
Weird a(5), b(10);
a = b;
```
Although the statement `a = b` looks like an assignment statement, it actually causes the contents of b’s value member to be displayed on the screen:
```c++
10
```
Another operator overloading issue is you cannot change the number of operands taken by an operator. The `=` symbol must always be a binary operator. Likewise, `++` and `−−` must always be unary operators.

## Table 14-1
Operators that May be Overloaded
| `+`   | `-`  | `*`   | `/`   | `%`  | `^`   |
| ----- | ---- | ----- | ----- | ---- | ----- |
| `&`   | \|  | `~`   | `!`   | `=`  | `<`   |
| `>`   | `+=` | `-=`  | `*=`  | `/=` | `%=`  |
| `^=`  | `&=`   | \|=  | `<<`  | `>>` | `>>=` |
| `<<=` | `==` | `!=`  | `<=`  | `>=` | `&&`  |
| \| \|  | `++` | `--`  | `-<*` | `,`  | `-<`  |
| `[]`  | `()` | `new` | `delete`      |      |       |

The only operators that cannot be overloaded:
| `?:` | `.` | `.*` | `::` | `sizeof` |
| ---- | --- | ---- | ---- | -------- |

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading Math Operators
Many classes would benefit not only from an overloaded assignment operator, but also from overloaded math operators. To illustrate this, consider the `FeetInches` class shown in the following two files. 

#### Contents of `FeetInches.h` (v1)
```c++
 #ifndef FEETINCHES_H
 #define FEETINCHES_H
 
 // The FeetInches class holds distances or measurements
 // expressed in feet and inches.
 
 class FeetInches
 {
 private:
    int feet;         // To hold a number of feet
    int inches;       // To hold a number of inches
    void simplify();  // Defined in FeetInches.cpp
 public:
     // Constructor
     FeetInches(int f = 0, int i = 0)
         { feet = f;
          inches = i;
          simplify(); }
          
     // Mutator functions
     void setFeet(int f)
          { feet = f; }

     void setInches(int i)
        { inches = i;
        simplify(); }

     // Accessor functions
     int getFeet() const
         { return feet; }

     int getInches() const
         { return inches; }

     // Overloaded operator functions
     FeetInches operator + (const FeetInches &); // Overloaded +
     FeetInches operator − (const FeetInches &); // Overloaded −
 };

 #endif
```

#### Contents of FeetInches.cpp (v1)
```c++
// Implementation file for the FeetInches class
#include <cstdlib> // Needed for abs()
#include "FeetInches.h"

//**************************************************************
// Definition of member function simplify. This function       *
// checks for values in the inches member greater than         *
// twelve or less than zero. If such a value is found,         *
// the numbers in feet and inches are adjusted to conform      *
// to a standard feet & inches expression. For example,        *
// 3 feet 14 inches would be adjusted to 4 feet 2 inches and   *
// 5 feet −2 inches would be adjusted to 4 feet 10 inches.     *
//**************************************************************

void FeetInches::simplify()
{
   if (inches >= 12)
   {
       feet += (inches / 12);
       inches = inches % 12;
   }
   else if (inches < 0)
   {
       feet −= ((abs(inches) / 12) + 1);
       inches = 12 − (abs(inches) % 12);
   }
}

//**********************************************
// Overloaded binary + operator.               *
//**********************************************

FeetInches FeetInches::operator + (const FeetInches &right)
{
   FeetInches temp;
   temp.inches = inches + right.inches;
   temp.feet = feet + right.feet;
   temp.simplify();
   return temp;
}

//**********************************************
// Overloaded binary − operator.               *
//**********************************************

FeetInches FeetInches::operator − (const FeetInches &right)
{
    FeetInches temp;

    temp.inches = inches − right.inches;
    temp.feet = feet − right.feet;
    temp.simplify();
    return temp;
}
```
The `FeetInches` class is designed to hold distances or measurements expressed in feet and inches. It consists of eight member functions:
- A constructor that allows the feet and inches members to be set. The default values for these members is zero.
- `setFeet` — a function for storing a value in the feet member
- `setInches` — a function for storing a value in the inches member
- `getFeet` — a function for returning the value in the feet member
- `getInches` — a function for returning the value in the inches member
- `simplify` — a function for normalizing the values held in feet and inches. This function adjusts any set of values where the inches member is greater than 12 or less than 0.
- `operator +` —a function that overloads the standard + math operator
- `operator −` —a function that overloads the standard − math operator
***
**NOTE:** The simplify function uses the standard library function `abs()` to get the absolute value of the inches member. The `abs()` function requires that `cstdlib` be included.
***
The overloaded + and − operators allow one `FeetInches` object to be added to or subtracted from another. For example, assume the `length1` and `length2` objects are defined and initialized as follows:
```c++
FeetInches length1(3, 5), length2(6, 3);
```

The `length1` object is holding the value 3 feet 5 inches, and the `length2` object is holding the value 6 feet 3 inches. Because the `+` operator is overloaded, we can add these two objects in a statement such as:
```c++
length3 = length1 + length2;
```

This statement will add the values of the `length1` and `length2` objects and store the result in the `length3` object. After the statement executes, the `length3` object will be set to 9 feet 8 inches.

This function is called anytime the `+` operator is used with two `FeetInches` objects. Just like the overloaded `=` operator we defined in the previous section, this function has one parameter: a constant reference object named `right`. This parameter references the object on the right side of the operator. For example, when the following statement is executed, `right` will reference the `length2` object:
```c++
length3 = length1 + length2;
```

As before, it might be helpful to think of the statement above as the following function call:
```c++
length3 = length1.operator+(length2);
```

The `length2` object is being passed to the function’s parameter, `right`. When the function finishes, it will return a `FeetInches` object to `length3`. Now let’s see what is happening inside the function. First, notice a `FeetInches` object named `temp` is defined locally in line 35:
```c++
FeetInches temp;
```

This object is a temporary location for holding the results of the addition. Next, line 37 adds inches to right. `inches` and stores the result in `temp.inches`:
```c++
temp.inches = inches + right.inches;
```

The inches variable is a member of `length1`, the object making the function call. It is the object on the left side of the operator.` right.inches` references the inches member of `length2`. The next statement, in line 38, is very similar. It adds feet to `right.feet` and stores the result in `temp.feet`.
```c++
temp.feet = feet + right.feet;
```

At this point in the function, `temp` contains the sum of the `feet` and `inches` members of both objects in the expression. The next step is to adjust the values, so they conform to a normal value expressed in `feet` and `inches`. This is accomplished in line 39 by calling `temp.simplify()`:
```c++
temp.simplify();
```

The last step, in line 40, is to return the value stored in `temp`:
```c++
return temp;
```

In the statement `length3` = `length1` + `length2`, the return statement in the operator function causes the values stored in `temp` to be returned to the `length3` object.

## Program 14-8
Demonstrates the overloaded operators
```c++
// This program demonstrates the FeetInches class's overloaded
// + and − operators.
#include <iostream>
#include "FeetInches.h"
using namespace std;

int main()
{
   int feet, inches; // To hold input for feet and inches

   // Create three FeetInches objects. The default arguments
   // for the constructor will be used.
   FeetInches first, second, third;

   // Get a distance from the user.
   cout << "Enter a distance in feet and inches: ";
   cin >> feet >> inches;

   // Store the distance in the first object.
   first.setFeet(feet);
   first.setInches(inches);

   // Get another distance from the user.
   cout << "Enter another distance in feet and inches: ";
   cin >> feet >> inches;

   // Store the distance in second.
   second.setFeet(feet);
   second.setInches(inches);

   // Assign first + second to third.
   third = first + second;

   // Display the result.
   cout << "first + second = ";
   cout << third.getFeet() << " feet, ";
   cout << third.getInches() << " inches.\n";

   // Assign first − second to third.
   third = first − second;

   // Display the result.
   cout << "first − second = ";
   cout << third.getFeet() << " feet, ";
   cout << third.getInches() << " inches.\n";

   return 0;
}

// =============== Output ===============
// Enter a distance in feet and inches: 6 5 Enter
// Enter another distance in feet and inches: 3 10 Enter
// first + second = 10 feet, 3 inches.
// first − second = 2 feet, 7 inches.
// ======================================
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading the Prefix `++` Operator
Unary operators, such as `++` and `– –`, are overloaded in a fashion similar to the way binary operators are implemented. Because unary operators only affect the object making the operator function call, however, there is no need for a parameter. For example, let’s say you wish to have a prefix increment operator for the `FeetInches` class. Assume the `FeetInches` object distance is set to the values 7 feet and 5 inches. A `++` operator function could be designed to increment the object’s `inches` member. The following statement would cause `distance` to have the value 7 feet 6 inches:
```c++
++distance;
```

The following function overloads the prefix `++` operator to work in this fashion:
```c++
FeetInches FeetInches::operator++() {
  ++inches;
  simplify();
  return *this;
}
```

This function first increments the object’s `inches` member. The `simplify()` function is called then the dereferenced `this` pointer is returned. This allows the operator to perform properly in statements like this:
```c++
distance2 = ++distance1;
```

Remember, the statement above is equivalent to
```c++
distance2 = distance1.operator++();
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading the Postfix `++` Operator
Overloading the postfix `++` operator is only slightly different than overloading the prefix version. Here is the function that overloads the postfix operator with the `FeetInches` class:
```c++
FeetInches FeetInches::operator++(int) {
  FeetInches temp(feet, inches);
  inches++;
  simplify();
  return temp;
}
```

The first difference you will notice is the use of a *dummy parameter*. The word `int` in the function’s parentheses establishes a nameless integer parameter. When C++ sees this parameter in an operator function, it knows the function is designed to be used in postfix mode. The second difference is the use of a temporary local variable, the `temp` object. `temp` is initialized with the `feet` and `inches` values of the object making the function call. `temp`, therefore, is a copy of the object being incremented, but before the increment takes place. After inches is incremented and the `simplify` function is called, the contents of `temp` is returned. This causes the postfix operator to behave correctly in a statement like this:
```c++
distance 2 = distance1++;
```

## Someone remind me to include Program 14-9 Here because for now it's the output
### `FeetInches v2` Program
```c++
// ===================== Output =====================
// Demonstrating prefix ++ operator.
// first: 1 feet 6 inches. second: 1 feet 6 inches.
// first: 1 feet 7 inches. second: 1 feet 7 inches.
// first: 1 feet 8 inches. second: 1 feet 8 inches.
// first: 1 feet 9 inches. second: 1 feet 9 inches.
// first: 1 feet 10 inches. second: 1 feet 10 inches.
// first: 1 feet 11 inches. second: 1 feet 11 inches.
// first: 2 feet 0 inches. second: 2 feet 0 inches.
// first: 2 feet 1 inches. second: 2 feet 1 inches.
// first: 2 feet 2 inches. second: 2 feet 2 inches.
// first: 2 feet 3 inches. second: 2 feet 3 inches.
// first: 2 feet 4 inches. second: 2 feet 4 inches.
// first: 2 feet 5 inches. second: 2 feet 5 inches.
// 
// Demonstrating postfix ++ operator.
// first: 2 feet 5 inches. second: 2 feet 6 inches.
// first: 2 feet 6 inches. second: 2 feet 7 inches.
// first: 2 feet 7 inches. second: 2 feet 8 inches.
// first: 2 feet 8 inches. second: 2 feet 9 inches.
// first: 2 feet 9 inches. second: 2 feet 10 inches.
// first: 2 feet 10 inches. second: 2 feet 11 inches.
// first: 2 feet 11 inches. second: 3 feet 0 inches.
// first: 3 feet 0 inches. second: 3 feet 1 inches.
// first: 3 feet 1 inches. second: 3 feet 2 inches.
// first: 3 feet 2 inches. second: 3 feet 3 inches.
// first: 3 feet 3 inches. second: 3 feet 4 inches.
// first: 3 feet 4 inches. second: 3 feet 5 inches.
// ===================================================
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading Relational Operators
In addition to the assignment and math operators, relational operators may be overloaded. This capability allows classes to be compared in statements that use relational expressions such as:
```c++
if (distance1 < distance2)
{
	...code...
}
```

Overloaded relational operators are implemented like other binary operators. The only difference is that a relational operator function should always return a true or false value. The third version of the `FeetInches` class contains functions to overload the `>, <, and ==` relational operators. Here is the function for overloading the `>` operator:
```c++
bool FeetInches::operator>(const FeetInches &right) {
  bool status;
  if (feet > right.feet)
    status = true;
  else if (feet == right.feet && inches > right.inches)
    status = true;
  else
    status = false;
  return status;
}
```

As you can see, the function compares the `feet` member (and if necessary, the `inches` member) with that of the parameter. If the calling object contains a value greater than that of the parameter, true is returned. Otherwise, false is returned. Here is the code that overloads the `<` operator:
```c++
bool FeetInches::operator<(const FeetInches &right) {
  bool status;
  if (feet < right.feet)
    status = true;
  else if (feet == right.feet && inches < right.inches)
    status = true;
  else
    status = false;
  return status;
}
```

Here is the code that overloads the `==` operator:
```c++
bool FeetInches::operator==(const FeetInches &right) {
  bool status;
  if (feet == right.feet && inches == right.inches)
    status = true;
  else
    status = false;
  return status;
}
```

## Program 14-10
Demonstrates the overloaded operators.
```c++
 // This program demonstrates the FeetInches class's overloaded
 // relational operators.
 #include <iostream>
 #include "FeetInches.h"
 using namespace std;

 int main()
 {
     int feet, inches; // To hold input for feet and inches

     // Create two FeetInches objects. The default arguments
     // for the constructor will be used.
     FeetInches first, second;

     // Get a distance from the user.
     cout << "Enter a distance in feet and inches: ";
     cin >> feet >> inches;

     // Store the distance in first.
     first.setFeet(feet);
     first.setInches(inches);

     // Get another distance.
     cout << "Enter another distance in feet and inches: ";
     cin >> feet >> inches;

     // Store the distance in second.
     second.setFeet(feet);
     second.setInches(inches);

     // Compare the two objects.
     if (first == second)
        cout << "first is equal to second.\n";

     if (first > second)
        cout << "first is greater than second.\n";
        
     if (first < second)
        cout << "first is less than second.\n";

     return 0;
 }

// =============== Example Output 1 ================
// Enter a distance in feet and inches: 6 5 [Enter]
// Enter another distance in feet and inches: 3 10 [Enter]
// first is greater than second.
// =================================================

// =============== Example Output 2 ================
// Enter a distance in feet and inches: 5 5 [Enter]
// Enter another distance in feet and inches: 5 5 [Enter]
// first is equal to second.
// =================================================

// =============== Example Output 3 ================
// Enter a distance in feet and inches: 3 4 [Enter]
// Enter another distance in feet and inches: 3 7 [Enter]
// first is less than second.
// =================================================
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading the `<<` and `>>` Operators
Overloading the math and relational operators gives you the ability to write those types of expressions with class objects just as naturally as with integers, floats, and other built-in data types. If an object’s primary data members are private, however, you still have to make explicit member function calls to send their values to `cout`. For example, assume distance is a `FeetInches` object. The following statements display its internal values:
```c++
cout << distance.getFeet() << " feet, ";
cout << distance.getInches() << "inches";
```

It is also necessary to explicitly call member functions to set a `FeetInches` object’s data. For instance, the following statements set the distance object to user-specified values:
```c++
cout << "Enter a value in feet: "; cin >> f; distance.setFeet(f); cout << "Enter a value in inches: "; cin >> i; distance.setInches(i);
```

By overloading the stream insertion operator (`<<`), you could send the distance object to `cout`, as shown in the following code, and have the screen output automatically formatted in the correct way:
```c++
cout << distance;
```

Likewise, by overloading the stream extraction operator (`>>`), the distance object could take values directly from `cin`, as shown here:
```c++
cin >> distance;
```

Overloading these operators is done in a slightly different way, however, than overloading other operators. These operators are actually part of the `ostream` and `istream` classes defined in the C++ runtime library. You must write operator functions to overload the `ostream` version of `<<` and the `istream` version of `>>`, so they work directly with a class such as `FeetInches`. The `FeetInches` class contains functions to overload the `<<` and `>>` operators. Here is the function that overloads the `<<` operator:
```c++
ostream &operator<<(ostream &strm, const FeetInches &obj) {
  strm << obj.feet << " feet, " << obj.inches << " inches";
  return strm;
}
```

Notice the function has two parameters: an `ostream` reference object and a `const FeetInches` reference object. The `ostream` parameter will be a reference to the actual `ostream` object on the left side of the `<<` operator. The second parameter is a reference to a `FeetInches` object. This parameter will reference the object on the right side of the `<<` operator. This function tells C++ how to handle any expression that has the following form:
```c++
ostreamObject << FeetInchesObject
```

So, when C++ encounters the following statement, it will call the overloaded `operator<<` function:
```c++
cout << distance;
```

Notice the function’s return type is` ostream &`. This means the function returns a reference to an `ostream` object. When the `return strm;` statement executes, it doesn’t return a copy of `strm`, but a reference to it. This allows you to chain together several expressions using the overloaded `<<` operator, such as:
```c++
cout << distance1 << " " << distance2 << endl;
```

Here is the function that overloads the stream extraction operator to work with the `FeetInches` class:
```c++
istream &operator>>(istream &strm, FeetInches &obj) {
  // Prompt the user for the feet.
  cout << "Feet: ";
  strm >> obj.feet;
  // Prompt the user for the inches.
  cout << "Inches: ";
  strm >> obj.inches;
  // Normalize the values.
  obj.simplify();
  return strm;
}
```

The same principles hold true for this operator. It tells C++ how to handle any expression in the following form:
```c++
istreamObject >> FeetInchesObject
```

Once again, the function returns a reference to an `istream` object, so several of these expressions may be chained together.

You have probably realized that neither of these functions is quite ready to work, though. Both functions attempt to directly access the `FeetInches` object’s private members. Because the functions aren’t themselves members of the `FeetInches` class, they don’t have this type of access. The next step is to make the operator functions friends of `FeetInches`. This is shown in the following listing of the `FeetInches` class declaration. 
***
**NOTE:** Some compilers require you to prototype the `>>` and `<<` operator functions outside the class. For this reason, we have added the following statements to the `FeetInches.h` class specification file.
***
```c++
class FeetInches;  // Forward Declaration

// Function Prototypes for Overloaded Stream Operators
ostream &operator<<(ostream &, const FeetInches &);
istream &operator>>(istream &, FeetInches &);
```

#### Contents of `FeetInches.h` (v4)
```c++
#ifndef FEETINCHES_H
#define FEETINCHES_H

#include <iostream>
using namespace std;

class FeetInches; // Forward Declaration

// Function Prototypes for Overloaded Stream Operators
ostream &operator << (ostream &, const FeetInches &);
istream &operator >> (istream &, FeetInches &);

// The FeetInches class holds distances or measurements
// expressed in feet and inches.

class FeetInches
{
private:
   int feet;         // To hold a number of feet
   int inches;       // To hold a number of inches
   void simplify();  // Defined in FeetInches.cpp
public:
   // Constructor
   FeetInches(int f = 0, int i = 0)
     { feet = f;
       inches = i;
       simplify(); }

   // Mutator functions
   void setFeet(int f)
    { feet = f; }

   void setInches(int i)
    { inches = i;
     simplify(); }

   // Accessor functions
   int getFeet() const
    { return feet; }

   int getInches() const
    { return inches; }

   // Overloaded operator functions
   FeetInches operator + (const FeetInches &);  // Overloaded +
   FeetInches operator − (const FeetInches &);  // Overloaded −
   FeetInches operator ++ ();                   // Prefix ++
   FeetInches operator ++ (int);                // Postfix ++
   bool operator > (const FeetInches &);        // Overloaded >
   bool operator < (const FeetInches &);        // Overloaded <
   bool operator == (const FeetInches &);       // Overloaded ==

   // Friends
   friend ostream &operator << (ostream &, const FeetInches &);
   friend istream &operator >> (istream &, FeetInches &);
};

#endif
```

Lines 54 and 55 in the class declaration tell C++ to make the overloaded `<<` and `>>` operator functions friends of the `FeetInches` class:
```c++
friend ostream &operator << (ostream &, const FeetInches &);
friend istream &operator >> (istream &, FeetInches &);
```
These statements give the operator functions direct access to the `FeetInches` class's private members.

## Program 14-11
Demonstrates how the overloaded operators work.
```c++
// This program demonstrates the << and >> operators,
// overloaded to work with the FeetInches class.
#include <iostream>
#include "FeetInches.h"
using namespace std;

int main()
{
   FeetInches first, second; // Define two objects.

   // Get a distance for the first object.
   cout << "Enter a distance in feet and inches.\n";
   cin >> first;

   // Get a distance for the second object.
   cout << "Enter another distance in feet and inches.\n";
   cin >> second;

   // Display the values in the objects.
   cout << "The values you entered are:\n";
   cout << first << " and " << second << endl;
   return 0;
}

// =============== Output ===============
// Enter a distance in feet and inches.
// Feet: 6 [Enter]
// Inches: 5 [Enter]
// Enter another distance in feet and inches.
// Feet: 3 [Enter]
// Inches: 10 [Enter]
// The values you entered are:
// 6 feet, 5 inches and 3 feet, 10 inches
// ======================================
```

#### [BACK TO THE TOP](#Table-of-Contents)

# Overloading the Subscript Operator
In addition to the traditional operators, C++ allows you to change the way the `[]` symbols work. This gives you the ability to write classes that have array-like behaviors. For example, the `string` class overloads the `[]` operator, so you can access the individual characters stored in `string` class objects. Assume the following definition exists in a program:
```c++
string name = "William";
```

The first character in the string, `‘W’`, is stored at `name[0]`, so the following statement will display `W` on the screen.
```c++
cout << name[0];
```

You can use the overloaded `[]` operator to create an array class, like the following one. The class behaves like a regular array, but performs the bounds checking that C++ lacks.

#### Contents of `IntArray.h`
```c++
 // Specification file for the IntArray class
 #ifndef INTARRAY_H
 #define INTARRAY_H

 class IntArray
 {
 private:
    int *aptr;                                     // Pointer to the array
    intarraySize;                                  // Holds the array size
    void subscriptError();                         // Handles invalid subscripts
 public:
    IntArray(int);                                 // Constructor
    IntArray(const IntArray &);                    // Copy constructor
    ~IntArray();                                   // Destructor

    int size() const                               // Returns the array size
       { return arraySize; }

    const IntArray operator=(const IntArray &);    // Overloaded = operator
    int &operator[](const int &);                  // Overloaded [] operator
 };
 #endif
```

#### Contents of IntArray.cpp
```c++
// Implementation file for the IntArray class
#include <iostream>
#include <cstdlib> // For the exit function
#include "IntArray.h"
using namespace std;

//********************************************************
// Constructor for IntArray class. Sets the size of the  *
// array and allocates memory for it.                    *
//********************************************************
IntArray::IntArray(int s)
{
   arraySize = s;
   aptr = new int[s];
   
   for (int count = 0; count < arraySize; count++)
      *(aptr + count) = 0;
}

//********************************************************
// Copy Constructor for IntArray class.                  *
//********************************************************
IntArray::IntArray(const IntArray &obj)
{
   ArraySize = obj.arraySize;
   aptr = new int[arraySize];
   
   for(int count = 0; count < arraySize; count++)
     *(aptr + count) = *(obj.aptr + count);
}

//********************************************************
// Destructor for IntArray class.                        *
//********************************************************
IntArray::~IntArray()
{
   if (arraySize > 0)
	   delete [] aptr;
}

//************************************************************
// subscriptError function. Displays an error message and    *
// terminates the program when a subscript is out of range.  *
//************************************************************
void IntArray::subscriptError()
{
   cout << "ERROR: Subscript out of range.\n";
   exit(0);
}

//********************************************************
// Overloaded = operator                                 *
//********************************************************
const IntArray IntArray::operator=(const IntArray &right)
{
   if (this != &right)
   {
      delete[] aptr;
      arraySize = right.arraySize;
      aptr = new int[arraySize];
      
      for (int count = 0; count < arraySize; count++)
         *(aptr + count) = *(right.aptr + count);
   }
   return *this;
}

//********************************************************
// Overloaded [] operator. The argument is a subscript.  *
// This function returns a reference to the element      *
// in the array indexed by the subscript.                *
//********************************************************
int &IntArray::operator[](const int &sub)
{
   if (sub < 0 || sub >= arraySize)
	   subscriptError();
    
   return aptr[sub];
}
```

Before focusing on the overloaded `[]` operator, let’s look at the constructors and the destructor. The code for the first constructor in lines 11 through 17 of the `IntArray.cpp` file follows:
```c++
IntArray::IntArray(int s) {
  arraySize = s;
  aptr = new int[s];
  for (int count = 0; count < arraySize; count++) *(aptr + count) = 0;
}
```

When an instance of the class is defined, the required number of elements is passed into the constructor’s parameter, `s`. This value is assigned to the `arraySize` member, then used to dynamically allocate enough memory for the array. The constructor’s final step is to store zeros in all of the array’s elements.

The class also has a copy constructor in lines 22 through 28 which is used when a class object is initialized with another object’s data:
```c++
IntArray::IntArray(const IntArray &obj) {
  arraySize = obj.arraySize;
  aptr = new int[arraySize];
  for (int count = 0; count < arraySize; count++)
    *(aptr + count) = *(obj.aptr + count);
}
```

A reference to the initializing object is passed into the parameter `obj`. Once the memory is successfully allocated for the array, the constructor copies all the values in `obj`’s array into the calling object’s array.

The destructor, in lines 33 through 37, simply frees the memory allocated by the class’s constructors. First, however, it checks the value in `arraySize` to be sure the array has at least one element:
```c++
IntArray::~IntArray() {
  if (arraySize > 0)
	  delete[] aptr;
}
```

The `[]` operator is overloaded similarly to other operators. The definition of the `operator[]` function appears in lines 70 through 75:
```c++
int &IntArray::operator[](const int &sub) {
  if (sub < 0 || sub >= arraySize) subscriptError();
  return aptr[sub];
}
```

The `operator[]` function can have only a single parameter. The one shown uses a constant reference to an integer. This parameter holds the value placed inside the brackets in an expression. For example, if table is an `IntArray` object, the number 12 will be passed into the sub parameter in the following statement:
```c++
cout << table[12];
```
Inside the function, the value in the sub parameter is tested by the following if statement:
```c++
if (sub < 0 || sub >= arraySize)
	subscriptError();
```

This statement determines whether `sub` is within the range of the array’s subscripts. If `sub` is less than 0, or greater than or equal to `arraySize`, it’s not a valid subscript, so the `subscriptError` function is called. If `sub` is within range, the function uses it as an offset into the array and returns a reference to the value stored at that location.

One critically important aspect of the function above is its return type. It’s crucial that the function return not simply an integer, but a *reference* to an integer. The reason for this is that expressions such as the following must be possible:
```c++
table[5] = 27;
```

Remember, the built-in `=` operator requires the object on its left to be an `lvalue`. An `lvalue` must represent a modifiable memory location, such as a variable. The integer return value of a function is not an `lvalue`. If the `operator[]` function merely returns an integer, it can not be used to create expressions placed on the left side of an assignment operator.

A reference to an integer, however, is an `lvalue`. If the `operator[]` function returns a reference, it can be used to create expressions like the following:
```c++
table[7] = 52;
```
In this statement, the `operator[] `function is called with 7 passed as its argument. Assuming 7 is within range, the function returns a reference to the integer stored at `(aptr + 7)`. In essence, the statement above is equivalent to:
```c++
*[aptr + 7] = 52;
```

Because the `operator[`] function returns actual integers stored in the array, it is not necessary for math or relational operators to be overloaded. Even the stream operators `<<` and `>>` will work just as they are with the `IntArray` class.

## Program 14-12
```c++
// This program demonstrates an overloaded [] operator.
#include <iostream>
#include "IntArray.h"
using namespace std;

int main()
{
   const int SIZE = 10; // Array size
   
   // Define an IntArray with 10 elements.
   IntArray table(SIZE);

   // Store values in the array.
   for (int x = 0; x < SIZE; x++)
       table[x] = (x * 2);

   // Display the values in the array.
   for (int x = 0; x < SIZE; x++)
       cout << table[x] << " ";
   cout << endl;

   // Use the standard + operator on array elements.
   for (int x = 0; x < SIZE; x++)
       table[x] = table[x] + 5;

   // Display the values in the array.
   for (int x = 0; x < SIZE; x++)
       cout << table[x] << " ";
   cout << endl;

   // Use the standard ++ operator on array elements.
   for (int x = 0; x < SIZE; x++)
       table[x]++;

   // Display the values in the array.
   for (int x = 0; x < SIZE; x++)
       cout << table[x] << " ";
   cout << endl;

  return 0;
}

// ============ Output ============
// 0 2 4 6 8 10 12 14 16 18
// 5 7 9 11 13 15 17 19 21 23
// 6 8 10 12 14 16 18 20 22 24
// ================================
```

## Program 14-13
Demonstrates the `IntArray` class's bounds-checking capability
```c++
// This program demonstrates the IntArray class's bounds-checking ability.
#include <iostream>
#include "IntArray.h"
using namespace std;

int main()
{
   const int SIZE = 10; // Array size

   // Define an IntArray with 10 elements.
   IntArray table(SIZE);
   
   // Store values in the array.
   for (int x = 0; x < SIZE; x++)
       table[x] = x;

   // Display the values in the array.
   for (int x = 0; x < SIZE; x++)
       cout << table[x] << " ";
   cout << endl;

   // Attempt to use an invalid subscript.
   cout << "Now attempting to use an invalid subscript.\n";
   table[SIZE + 1] = 0;

   return 0;
}

// ================= Output =================
// 0 1 2 3 4 5 6 7 8 9
// Now attempting to use an invalid subscript.
// ERROR: Subscript out of range.
// ==========================================
```


#### [BACK TO THE TOP](#Table-of-Contents)

***
# Quiz for This Section
[Table of Contents](/README.md) | [Previous Section](14.4%20-%20Copy%20Constructors.md) | [Next Section](14.6%20-%20Object%20Conversion.md) | [All Sections](/Module%207/Pearson%20Notes/)