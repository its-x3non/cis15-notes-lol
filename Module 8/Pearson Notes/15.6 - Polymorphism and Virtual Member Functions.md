[Table of Contents](/README.md) | [Previous Section](15.6%20-%20Polymorphism%20and%20Virtual%20Member%20Functions.md) | [Next Section](15.7%20-%20Abstract%20Base%20Classes%20and%20Pure%20Virtual%20Functions.md) | [All Sections](/Module%208/Pearson%20Notes/)
***
#Module8 #PearsonNotes
### Since this is a long section here are a table of contents for each section (In Order):
#### Table of Contents
- 15.6 - Polymorphism and Virtual Member Functions
- [Polymorphism Requires References or Pointers](#Polymorphism-Requires-References-or-Pointers)
- [Base Class Pointers](#Base-Class-Pointers)
- [Base Class Pointers and References Know Only about Base Class Members](#Base-Class-Pointers-and-References-Know-Only-about-Base-Class-Members)
- [The “Is-a” Relationship Does Not Work in Reverse](#The-“Is-a”-Relationship-Does-Not-Work-in-Reverse)
- [Redefining versus Overriding](#Redefining-versus-Overriding)
- [Virtual Destructors](#Virtual-Destructors)
- [The `override` and `final` Key Words](#The-override-and-final-Key-Words)
- [Preventing a Member Function from Being Overridden](#Preventing-a-Member-Function-from-Being-Overridden)
***
# 15.6 - Polymorphism and Virtual Member Functions
Polymorphism allows an object reference variable or an object pointer to reference objects of different types and to call the correct member functions, depending upon the type of object being referenced.

Look at the following code for a function named `displayGrade`:
```c++
void displayGrade(const GradedActivity& activity)
{
  cout << setprecision(1) << fixed;
  cout << "The activity's numeric score is " << activity.getScore() << endl;
  cout << "The activity's letter grade is " << activity.getLetterGrade() << endl;
}
```

This function uses a `const GradedActivity` reference variable as its parameter. When a `GradedActivity` object is passed as an argument to this function, the function calls the object’s `getScore` and `getLetterGrade` member functions to display the numeric score and letter grade. The following code shows how we might call the function:
```c++
GradedActivity test(88.0); // The score is 88
displayGrade(test); // Pass test to displayGrade

// =============== Output ===============
// The activity's numeric score is 88.0
// The activity's letter grade is B
// ======================================
```

Recall the `GradedActivity` class is also the base class for the `FinalExam` class. Because of the “is-a” relationship between a base class and a derived class, an object of the `FinalExam` class is not just a `FinalExam` object. It is also a `GradedActivity` object. (A final exam is a graded activity.) Because of this relationship, we can also pass a `FinalExam` object to the `displayGrade` function. For example, look at the following code:
```c++
// There are 100 questions. The student missed 25.
FinalExam test2(100, 25);
displayGrade(test2);

// =============== Output ===============
// The activity's numeric score is 75.0
// The activity's letter grade is C
// ======================================
```

## Program 15-10
Because the parameter in the `displayGrade` function is a `GradedActivity` reference variable, it can reference any object that is derived from `GradedActivity`. A problem can occur with this type of code, however, when redefined member functions are involved. For example, recall that the `PassFailActivity` class is derived from the `GradedActivity` class. The `PassFailActivity` class redefines the `getLetterGrade` function. Although we can pass a `PassFailActivity` object as an argument to the `displayGrade` function, we will not get the results we wish. This is demonstrated in this program.
```c++
#include <iostream>
#include <iomanip>
#include "PassFailActivity.h"
using namespace std;

 // Function prototype
 void displayGrade(const GradedActivity &);

 int main()
 {
    // Create a PassFailActivity object. Minimum passing
    // score is 70.
    PassFailActivity test(70);

    // Set the score to 72.
    test.setScore(72);

    // Display the object's grade data. The letter grade
    // should be 'P'. What will be displayed?
    displayGrade(test);
    return 0;
 }

 //***************************************************************
 // The displayGrade function displays a GradedActivity object's *
 // numeric score and letter grade.                              *
 //***************************************************************

 void displayGrade(const GradedActivity &activity)
 {
    cout << setprecision(1) << fixed;
    cout << "The activity's numeric score is "
         << activity.getScore() << endl;
    cout << "The activity's letter grade is "
         << activity.getLetterGrade() << endl;
 }

// =============== Output ===============
// The activity's numeric score is 72.0
// The activity's letter grade is C
// ======================================
```
As you can see from the example output, the `getLetterGrade` member function returned `‘C’` instead of `‘P’`. This is because the `GradedActivity` class’s `getLetterGrade` function was executed instead of the `PassFailActivity` class’s version of the function.

This behavior happens because of the way C++ matches function calls with the correct function. This process is known as **binding**. In Program 15-10, C++ decides at compile time which version of the `getLetterGrade` function to execute when it encounters the call to the function in line 35. Even though we passed a `PassFailActivity` object to the `displayGrade` function, the activity parameter in the `displayGrade` function is a `GradedActivity` reference variable. Because it is of the `GradedActivity` type, the compiler binds the function call in line 35 with the `GradedActivity` class’s `getLetterGrade` function. When the program executes, it has already been determined by the compiler that the `GradedActivity` class’s `getLetterGrade` function will be called. The process of matching a function call with a function at compile time is called **static binding**.

To remedy this, the `getLetterGrade` function can be made virtual. A virtual function is a member function that is dynamically bound to function calls. In **dynamic binding**, C++ determines which function to call at runtime, depending on the type of the object responsible for the call. If a `GradedActivity` object is responsible for the call, C++ will execute the `GradedActivity::getLetterGrade` function. If a `PassFailActivity` object is responsible for the call, C++ will execute the `PassFailActivity::getLetterGrade` function.

**Virtual functions** are declared by placing the key word virtual before the return type in the base class’s function declaration, such as
```c++
virtual char getLetterGrade() const;
```

This declaration tells the compiler to expect `getLetterGrade` to be redefined in a derived class. The compiler does not bind calls to the function with the actual function. Instead, it allows the program to bind calls, at runtime, to the version of the function that belongs to the same class as the object responsible for the call.
***
**NOTE:** You place the virtual key word only in the function’s declaration or prototype. If the function is defined outside the class, you do not place the virtual key word in the function header.
***
The following code shows an updated version of the `GradedActivity` class, with the ­`getLetterGrade` function declared virtual.

#### Contents of `GradedActivity` (v3)
```c++
#ifndef GRADEDACTIVITY_H
#define GRADEDACTIVITY_H

// GradedActivity class declaration

class GradedActivity
{ 
protected:
    double score; // To hold the numeric score
public:
    // Default constructor
    GradedActivity()
       { score = 0.0; }

    // Constructor
    GradedActivity(double s)
       { score = s; }

    // Mutator function
    void setScore(double s)
       { score = s; }

    // Accessor functions
    double getScore() const
       { return score; }

    virtual char getLetterGrade() const;
 };
 #endif
```
The only change we have made to this class is to declare `getLetterGrade` as virtual in line 27. This tells the compiler not to bind calls to `getLetterGrade` with the function at compile time. Instead, calls to the function will be bound dynamically to the function at runtime.

When a member function is declared virtual in a base class, any redefined versions of the function that appear in derived classes automatically become virtual. So, it is not necessary to declare the `getLetterGrade` function in the `PassFailActivity` class as virtual. It is still a good idea to declare the function virtual in the `PassFailActivity` class for documentation purposes. A new version of the `PassFailActivity` class is shown here. The `PassFailActivity.cpp` file has not changed, so it is not shown again.

#### Contents of `PassFailActivity.h`
```c++
#ifndef PASSFAILACTIVITY_H
#define PASSFAILACTIVITY_H
#include "GradedActivity.h"

class PassFailActivity : public GradedActivity
{
 protected:
    double minPassingScore; // Minimum passing score
  public:
    // Default constructor
    PassFailActivity() : GradedActivity()
       { minPassingScore = 0.0; }

    // Constructor
    PassFailActivity(double mps) : GradedActivity()
       { minPassingScore = mps; }

    // Mutator
    void setMinPassingScore(double mps)
       { minPassingScore = mps; }

    // Accessors
    double getMinPassingScore() const
       { return minPassingScore; }

    virtual char getLetterGrade() const;
 };
 #endif
```

## Program 15-11
The only change we have made to this class is to declare `getLetterGrade` as virtual in line 26. Program 15-11 is identical to Program 15-10, except it uses the corrected version of the `GradedActivity` and `PassFailActivity` classes. 

#### [Back To The Top](#Table-of-Contents)

# Polymorphism Requires References or Pointers

#### [Back To The Top](#Table-of-Contents)

# Base Class Pointers

#### [Back To The Top](#Table-of-Contents)

# Base Class Pointers and References Know Only about Base Class Members
Although a base class pointer can reference objects of any class that derives from the base class, there are limits to what the pointer can do with those objects. Recall that the [`GradedActivity`](15.1%20-%20What%20is%20Inheritance.md#Base-Class-Example:-GradedActivity) class has, other than its constructors, only three member functions: `setScore`, `getScore`, and `getLetterGrade`. So, a `GradedActivity` pointer can be used to call only those ­functions, regardless of the type of object to which it points. For example, look at the ­follo­wing code:
```c++
GradedActivity *exam = new PassFailExam (100, 25, 70.0);
cout << exam–> getScore() << endl;       // This works.
cout << exam–> getLetterGrade() << endl; // This works.
cout << exam–> getPointsEach() << endl;  // ERROR! Won't work!
```
In this code, exam is a `GradedActivity` pointer, and is assigned the address of a `PassFailExam` object. The `GradedActivity` class has only the `setScore`, `getScore`, and `getLetterGrade` member functions, so those are the only member functions the exam variable knows how to execute. The last statement in this code is a call to the ­`getPointsEach` member function, which is defined in the `PassFailExam` class. Because the exam variable only knows about member functions in the `GradedActivity` class, it cannot execute this function.

#### [Back To The Top](#Table-of-Contents)

# The “Is-a” Relationship Does Not Work in Reverse)
It is important to note that the “is-a” relationship does not work in reverse. Although the statement “a final exam is a graded activity” is true, the statement “a graded activity is a final exam” is not true. This is because not all graded activities are final exams. Likewise, not all `GradedActivity` objects are `FinalExam` objects. So, the following code will not work:
```c++
// Create a GradedActivity object.
GradedActivity *gaPointer = new GradedActivity (88.0);

// Error! This will not work.
FinalExam *fePointer = gaPointer;
```

You cannot assign the address of a `GradedActivity` object to a `FinalExam` pointer. This makes sense because `FinalExam` objects have capabilities that go beyond those of a `GradedActivity` object. Interestingly, the C++ compiler will let you make such an assignment if you use a type cast, as shown here:
```c++
// Create a GradedActivity object.
GradedActivity *gaPointer = new GradedActivity (88.0);

// This will work, but with limitations.
FinalExam *fePointer = static_cast<FinalExam *> (gaPointer);
```

After this code executes, the derived class pointer `fePointer` will be pointing to a base class object. We can use the pointer to access members of the object, but only the members that exist. The following code demonstrates:
```c++
// This will work. The object has a getScore function.
cout << fePointer– > getScore () << endl;

// This will work. The object has a getLetterGrade function.
cout << fePointer– > getLetterGrade () << endl;

// This will compile, but an error will occur at runtime.
// The object does not have a getPointsEach function.
cout << fePointer– > getPointsEach () << endl;
```

In this code, `fePointer` is a `FinalExam` pointer, and it points to a `GradedActivity` object. The first two `cout` statements work because the `GradedActivity` object has `getScore` and a `getLetterGrade` member functions. The last `cout` statement will cause an error, however, because it calls the `getPointsEach` member function. The `GradedActivity` object does not have a `getPointsEach` member function.

#### [Back To The Top](#Table-of-Contents)

# Redefining versus Overriding
Earlier in this chapter, you learned how a derived class can redefine a base class member function. When a class redefines a virtual function, it is said that the class overrides the function. In C++, the difference between overriding and redefining base class functions is that overridden functions are dynamically bound, and redefined functions are statically bound. Only virtual functions can be overridden.

#### [Back To The Top](#Table-of-Contents)

# Virtual Destructors

#### [Back To The Top](#Table-of-Contents)

# The `override` and `final` Key Words

#### [Back To The Top](#Table-of-Contents)

# Preventing a Member Function from Being Overridden
In some derived classes, you might want to make sure a virtual member function cannot be overridden any further down the class hierarchy. When a member function is declared with the `final` key word, it cannot be overridden in a derived class. The following member function prototype is an example that uses the `final` key word:
```c++
virtual void message() const final;
```
If a derived class attempts to override a `final` member function, the compiler generates an error.

#### [Back To The Top](#Table-of-Contents)


***
[Table of Contents](/README.md) | [Previous Section](15.6%20-%20Polymorphism%20and%20Virtual%20Member%20Functions.md) | [Next Section](15.7%20-%20Abstract%20Base%20Classes%20and%20Pure%20Virtual%20Functions.md) | [All Sections](/Module%208/Pearson%20Notes/)